"use strict";(globalThis.webpackChunkphysical_ai_textbook=globalThis.webpackChunkphysical_ai_textbook||[]).push([[8561],{4728(n,r,e){e.r(r),e.d(r,{assets:()=>l,contentTitle:()=>s,default:()=>d,frontMatter:()=>a,metadata:()=>t,toc:()=>c});const t=JSON.parse('{"id":"module-3-control-systems","title":"Chapter 3 - Control Systems and Motion Planning","description":"Motion Planning Algorithms","source":"@site/docs/module-3-control-systems.md","sourceDirName":".","slug":"/module-3-control-systems","permalink":"/ur/docs/module-3-control-systems","draft":false,"unlisted":false,"editUrl":"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/module-3-control-systems.md","tags":[],"version":"current","frontMatter":{"id":"module-3-control-systems","title":"Chapter 3 - Control Systems and Motion Planning","sidebar_label":"Chapter 3 - Control Systems and Motion Planning"},"sidebar":"tutorialSidebar","previous":{"title":"Chapter 2 - Perception Systems with Isaac","permalink":"/ur/docs/module-3-perception-systems"},"next":{"title":"Chapter 4 - AI-Driven Decision Making","permalink":"/ur/docs/module-3-decision-making"}}');var i=e(4848),o=e(8453);const a={id:"module-3-control-systems",title:"Chapter 3 - Control Systems and Motion Planning",sidebar_label:"Chapter 3 - Control Systems and Motion Planning"},s="Chapter 3: Control Systems and Motion Planning",l={},c=[{value:"Motion Planning Algorithms",id:"motion-planning-algorithms",level:2},{value:"Motion Planning Concepts in Isaac",id:"motion-planning-concepts-in-isaac",level:3},{value:"Path Planning Algorithms",id:"path-planning-algorithms",level:3},{value:"Obstacle Avoidance and Navigation",id:"obstacle-avoidance-and-navigation",level:3},{value:"Inverse Kinematics and Trajectory Generation",id:"inverse-kinematics-and-trajectory-generation",level:2},{value:"Inverse Kinematics in Isaac",id:"inverse-kinematics-in-isaac",level:3},{value:"Trajectory Generation Techniques",id:"trajectory-generation-techniques",level:3},{value:"Smooth Motion Planning",id:"smooth-motion-planning",level:3},{value:"Balance and Locomotion Control",id:"balance-and-locomotion-control",level:2},{value:"Balance Control Systems in Isaac",id:"balance-control-systems-in-isaac",level:3},{value:"Locomotion Planning for Humanoid Robots",id:"locomotion-planning-for-humanoid-robots",level:3},{value:"Walking and Standing Stability",id:"walking-and-standing-stability",level:3},{value:"Manipulation and Grasping Controllers",id:"manipulation-and-grasping-controllers",level:2},{value:"Manipulation Control in Isaac",id:"manipulation-control-in-isaac",level:3},{value:"Grasping Algorithms and Planning",id:"grasping-algorithms-and-planning",level:3},{value:"End-effector Control",id:"end-effector-control",level:3},{value:"Adaptive Control Systems",id:"adaptive-control-systems",level:2},{value:"Adaptive Control Concepts",id:"adaptive-control-concepts",level:3},{value:"Learning-based Control Approaches",id:"learning-based-control-approaches",level:3},{value:"Real-time Adaptation Techniques",id:"real-time-adaptation-techniques",level:3},{value:"Safety and Stability Considerations",id:"safety-and-stability-considerations",level:3},{value:"Conclusion",id:"conclusion",level:2}];function p(n){const r={code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,o.R)(),...n.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(r.header,{children:(0,i.jsx)(r.h1,{id:"chapter-3-control-systems-and-motion-planning",children:"Chapter 3: Control Systems and Motion Planning"})}),"\n",(0,i.jsx)(r.h2,{id:"motion-planning-algorithms",children:"Motion Planning Algorithms"}),"\n",(0,i.jsx)(r.p,{children:"Motion planning is a fundamental component of the AI-robot brain, enabling humanoid robots to navigate complex environments and execute tasks safely and efficiently. Isaac provides a comprehensive set of motion planning algorithms optimized for GPU acceleration and real-time performance."}),"\n",(0,i.jsx)(r.h3,{id:"motion-planning-concepts-in-isaac",children:"Motion Planning Concepts in Isaac"}),"\n",(0,i.jsx)(r.p,{children:"Isaac's motion planning framework encompasses several key concepts:"}),"\n",(0,i.jsxs)(r.ul,{children:["\n",(0,i.jsxs)(r.li,{children:[(0,i.jsx)(r.strong,{children:"Path Planning"}),": Computing geometric paths from start to goal positions"]}),"\n",(0,i.jsxs)(r.li,{children:[(0,i.jsx)(r.strong,{children:"Trajectory Planning"}),": Generating time-parameterized paths with velocity and acceleration profiles"]}),"\n",(0,i.jsxs)(r.li,{children:[(0,i.jsx)(r.strong,{children:"Collision Avoidance"}),": Ensuring safe navigation around obstacles"]}),"\n",(0,i.jsxs)(r.li,{children:[(0,i.jsx)(r.strong,{children:"Dynamic Planning"}),": Adapting plans in response to changing environments"]}),"\n",(0,i.jsxs)(r.li,{children:[(0,i.jsx)(r.strong,{children:"Multi-constraint Optimization"}),": Balancing multiple objectives in planning"]}),"\n"]}),"\n",(0,i.jsx)(r.h3,{id:"path-planning-algorithms",children:"Path Planning Algorithms"}),"\n",(0,i.jsx)(r.p,{children:"Isaac implements several path planning algorithms optimized for robotics applications:"}),"\n",(0,i.jsxs)(r.ul,{children:["\n",(0,i.jsxs)(r.li,{children:[(0,i.jsx)(r.strong,{children:"RRT (Rapidly-exploring Random Trees)"}),": Probabilistically complete planning algorithm"]}),"\n",(0,i.jsxs)(r.li,{children:["*",(0,i.jsx)(r.em,{children:"RRT"})," (Optimal RRT)**: Asymptotically optimal variant of RRT"]}),"\n",(0,i.jsxs)(r.li,{children:[(0,i.jsx)(r.strong,{children:"PRM (Probabilistic Roadmap)"}),": Multi-query planning approach"]}),"\n",(0,i.jsxs)(r.li,{children:[(0,i.jsx)(r.strong,{children:"Dijkstra and A"}),"*: Graph-based optimal path planning"]}),"\n",(0,i.jsxs)(r.li,{children:[(0,i.jsx)(r.strong,{children:"Potential Field Methods"}),": Gradient-based navigation"]}),"\n"]}),"\n",(0,i.jsx)(r.pre,{children:(0,i.jsx)(r.code,{className:"language-python",children:'# Example: Isaac motion planning implementation\r\nimport rclpy\r\nfrom rclpy.node import Node\r\nfrom geometry_msgs.msg import PoseStamped, Point\r\nfrom nav_msgs.msg import Path, OccupancyGrid\r\nfrom visualization_msgs.msg import Marker, MarkerArray\r\nfrom sensor_msgs.msg import LaserScan\r\nimport numpy as np\r\nfrom scipy.spatial import distance\r\nimport heapq\r\n\r\nclass IsaacMotionPlanner(Node):\r\n    def __init__(self):\r\n        super().__init__(\'isaac_motion_planner\')\r\n\r\n        # Subscribers\r\n        self.map_sub = self.create_subscription(\r\n            OccupancyGrid, \'/map\', self.map_callback, 10)\r\n\r\n        self.laser_sub = self.create_subscription(\r\n            LaserScan, \'/scan\', self.laser_callback, 10)\r\n\r\n        self.goal_sub = self.create_subscription(\r\n            PoseStamped, \'/move_base_simple/goal\', self.goal_callback, 10)\r\n\r\n        # Publishers\r\n        self.path_pub = self.create_publisher(Path, \'/plan\', 10)\r\n        self.visualization_pub = self.create_publisher(MarkerArray, \'/planner_visualization\', 10)\r\n\r\n        # Initialize planner\r\n        self.initialize_planner()\r\n\r\n        # Planning parameters\r\n        self.map_data = None\r\n        self.map_resolution = None\r\n        self.map_origin = None\r\n        self.current_goal = None\r\n        self.current_pose = None\r\n\r\n        # Timer for replanning\r\n        self.planning_timer = self.create_timer(0.1, self.planning_callback)\r\n\r\n    def initialize_planner(self):\r\n        """Initialize Isaac\'s motion planning system"""\r\n        self.get_logger().info(\'Isaac Motion Planner initialized\')\r\n        # Initialize A* or other planning algorithm\r\n        self.a_star_planner = AStarPlanner()\r\n\r\n    def map_callback(self, msg):\r\n        """Handle map updates"""\r\n        self.map_data = np.array(msg.data).reshape(msg.info.height, msg.info.width)\r\n        self.map_resolution = msg.info.resolution\r\n        self.map_origin = msg.info.origin\r\n        self.get_logger().info(\'Map received and updated\')\r\n\r\n    def laser_callback(self, msg):\r\n        """Handle laser scan for local obstacle detection"""\r\n        # Process laser scan for local planning and obstacle avoidance\r\n        pass\r\n\r\n    def goal_callback(self, msg):\r\n        """Handle new goal pose"""\r\n        self.current_goal = msg\r\n        self.get_logger().info(f\'New goal received: ({msg.pose.position.x}, {msg.pose.position.y})\')\r\n        self.replan_path()\r\n\r\n    def planning_callback(self):\r\n        """Main planning callback"""\r\n        if self.current_goal is not None and self.map_data is not None:\r\n            self.replan_path()\r\n\r\n    def replan_path(self):\r\n        """Replan path to current goal"""\r\n        if self.current_pose is None or self.current_goal is None:\r\n            return\r\n\r\n        # Convert poses to grid coordinates\r\n        start_x, start_y = self.pose_to_grid(self.current_pose.pose)\r\n        goal_x, goal_y = self.pose_to_grid(self.current_goal.pose)\r\n\r\n        # Plan path using A*\r\n        path = self.a_star_planner.plan_path(self.map_data, start_x, start_y, goal_x, goal_y)\r\n\r\n        if path:\r\n            # Convert path back to world coordinates\r\n            world_path = self.path_to_world(path)\r\n            self.publish_path(world_path)\r\n        else:\r\n            self.get_logger().warn(\'No valid path found to goal\')\r\n\r\n    def pose_to_grid(self, pose):\r\n        """Convert world pose to grid coordinates"""\r\n        x = int((pose.position.x - self.map_origin.position.x) / self.map_resolution)\r\n        y = int((pose.position.y - self.map_origin.position.y) / self.map_resolution)\r\n        return x, y\r\n\r\n    def path_to_world(self, path):\r\n        """Convert grid path to world coordinates"""\r\n        world_path = Path()\r\n        world_path.header.frame_id = \'map\'\r\n        world_path.header.stamp = self.get_clock().now().to_msg()\r\n\r\n        for x, y in path:\r\n            point = Point()\r\n            point.x = x * self.map_resolution + self.map_origin.position.x\r\n            point.y = y * self.map_resolution + self.map_origin.position.y\r\n            point.z = 0.0  # Assuming 2D navigation\r\n\r\n            pose_stamped = PoseStamped()\r\n            pose_stamped.header = world_path.header\r\n            pose_stamped.pose.position = point\r\n            world_path.poses.append(pose_stamped)\r\n\r\n        return world_path\r\n\r\n    def publish_path(self, path):\r\n        """Publish planned path"""\r\n        self.path_pub.publish(path)\r\n\r\nclass AStarPlanner:\r\n    """A* path planning implementation"""\r\n\r\n    def __init__(self):\r\n        self.directions = [\r\n            (-1, -1), (-1, 0), (-1, 1),\r\n            (0, -1),           (0, 1),\r\n            (1, -1),  (1, 0),  (1, 1)\r\n        ]\r\n\r\n    def plan_path(self, grid, start_x, start_y, goal_x, goal_y):\r\n        """Plan path using A* algorithm"""\r\n        if not self.is_valid_cell(grid, start_x, start_y) or not self.is_valid_cell(grid, goal_x, goal_y):\r\n            return None\r\n\r\n        # Initialize open and closed sets\r\n        open_set = [(0, start_x, start_y)]\r\n        heapq.heapify(open_set)\r\n\r\n        came_from = {}\r\n        g_score = {(start_x, start_y): 0}\r\n        f_score = {(start_x, start_y): self.heuristic(start_x, start_y, goal_x, goal_y)}\r\n\r\n        while open_set:\r\n            current_f, current_x, current_y = heapq.heappop(open_set)\r\n\r\n            # Check if we reached the goal\r\n            if current_x == goal_x and current_y == goal_y:\r\n                return self.reconstruct_path(came_from, (current_x, current_y))\r\n\r\n            # Explore neighbors\r\n            for dx, dy in self.directions:\r\n                neighbor_x, neighbor_y = current_x + dx, current_y + dy\r\n\r\n                if not self.is_valid_cell(grid, neighbor_x, neighbor_y):\r\n                    continue\r\n\r\n                # Calculate tentative g_score\r\n                tentative_g = g_score[(current_x, current_y)] + self.distance(dx, dy)\r\n\r\n                if (neighbor_x, neighbor_y) not in g_score or tentative_g < g_score[(neighbor_x, neighbor_y)]:\r\n                    came_from[(neighbor_x, neighbor_y)] = (current_x, current_y)\r\n                    g_score[(neighbor_x, neighbor_y)] = tentative_g\r\n                    f_score[(neighbor_x, neighbor_y)] = tentative_g + self.heuristic(neighbor_x, neighbor_y, goal_x, goal_y)\r\n\r\n                    heapq.heappush(open_set, (f_score[(neighbor_x, neighbor_y)], neighbor_x, neighbor_y))\r\n\r\n        return None  # No path found\r\n\r\n    def is_valid_cell(self, grid, x, y):\r\n        """Check if a cell is valid for navigation"""\r\n        if x < 0 or x >= grid.shape[1] or y < 0 or y >= grid.shape[0]:\r\n            return False\r\n\r\n        # Check if cell is occupied (assuming 100 = occupied, 0 = free)\r\n        return grid[y, x] < 50  # Threshold for free space\r\n\r\n    def heuristic(self, x1, y1, x2, y2):\r\n        """Calculate heuristic distance (Euclidean)"""\r\n        return np.sqrt((x2 - x1)**2 + (y2 - y1)**2)\r\n\r\n    def distance(self, dx, dy):\r\n        """Calculate distance between adjacent cells"""\r\n        return np.sqrt(dx**2 + dy**2)\r\n\r\n    def reconstruct_path(self, came_from, current):\r\n        """Reconstruct path from came_from map"""\r\n        path = [current]\r\n        while current in came_from:\r\n            current = came_from[current]\r\n            path.append(current)\r\n\r\n        path.reverse()\r\n        return path\n'})}),"\n",(0,i.jsx)(r.h3,{id:"obstacle-avoidance-and-navigation",children:"Obstacle Avoidance and Navigation"}),"\n",(0,i.jsx)(r.p,{children:"Isaac provides sophisticated obstacle avoidance capabilities:"}),"\n",(0,i.jsxs)(r.ul,{children:["\n",(0,i.jsxs)(r.li,{children:[(0,i.jsx)(r.strong,{children:"Local Planning"}),": Real-time obstacle avoidance in dynamic environments"]}),"\n",(0,i.jsxs)(r.li,{children:[(0,i.jsx)(r.strong,{children:"Global Planning"}),": Long-term path optimization considering static obstacles"]}),"\n",(0,i.jsxs)(r.li,{children:[(0,i.jsx)(r.strong,{children:"Dynamic Obstacle Prediction"}),": Anticipating movement of dynamic obstacles"]}),"\n",(0,i.jsxs)(r.li,{children:[(0,i.jsx)(r.strong,{children:"Recovery Behaviors"}),": Handling navigation failures gracefully"]}),"\n"]}),"\n",(0,i.jsx)(r.h2,{id:"inverse-kinematics-and-trajectory-generation",children:"Inverse Kinematics and Trajectory Generation"}),"\n",(0,i.jsx)(r.p,{children:"Inverse kinematics (IK) and trajectory generation are critical for humanoid robot control, enabling precise manipulation and locomotion."}),"\n",(0,i.jsx)(r.h3,{id:"inverse-kinematics-in-isaac",children:"Inverse Kinematics in Isaac"}),"\n",(0,i.jsx)(r.p,{children:"Isaac provides GPU-accelerated inverse kinematics solvers optimized for humanoid robots:"}),"\n",(0,i.jsxs)(r.ul,{children:["\n",(0,i.jsxs)(r.li,{children:[(0,i.jsx)(r.strong,{children:"Analytical IK"}),": Closed-form solutions for specific kinematic chains"]}),"\n",(0,i.jsxs)(r.li,{children:[(0,i.jsx)(r.strong,{children:"Numerical IK"}),": Iterative methods for complex kinematic structures"]}),"\n",(0,i.jsxs)(r.li,{children:[(0,i.jsx)(r.strong,{children:"GPU Acceleration"}),": Parallel computation for real-time performance"]}),"\n",(0,i.jsxs)(r.li,{children:[(0,i.jsx)(r.strong,{children:"Multi-target IK"}),": Solving for multiple end-effectors simultaneously"]}),"\n"]}),"\n",(0,i.jsx)(r.pre,{children:(0,i.jsx)(r.code,{className:"language-cpp",children:'// Example: Isaac inverse kinematics implementation\r\n#include "rclcpp/rclcpp.hpp"\r\n#include "sensor_msgs/msg/joint_state.hpp"\r\n#include "geometry_msgs/msg/pose_stamped.hpp"\r\n#include "control_msgs/msg/joint_trajectory_controller_state.hpp"\r\n#include "trajectory_msgs/msg/joint_trajectory.hpp"\r\n#include <kdl/chainiksolverpos_nr.hpp>\r\n#include <kdl/chainfksolverpos_recursive.hpp>\r\n#include <kdl/frames.hpp>\r\n#include <kdl/chain.hpp>\r\n#include <kdl/jntarray.hpp>\r\n#include <kdl/chainjnttojacsolver.hpp>\r\n\r\nnamespace isaac_ros\r\n{\r\nnamespace control\r\n{\r\n\r\nclass IsaacInverseKinematics : public rclcpp::Node\r\n{\r\npublic:\r\n  explicit IsaacInverseKinematics(const rclcpp::NodeOptions & options)\r\n  : Node("isaac_inverse_kinematics", options)\r\n  {\r\n    // Subscribe to joint states\r\n    joint_state_sub_ = this->create_subscription<sensor_msgs::msg::JointState>(\r\n      "/joint_states", 10,\r\n      std::bind(&IsaacInverseKinematics::jointStateCallback, this, std::placeholders::_1));\r\n\r\n    // Subscribe to target poses\r\n    target_pose_sub_ = this->create_subscription<geometry_msgs::msg::PoseStamped>(\r\n      "/ik_target", 10,\r\n      std::bind(&IsaacInverseKinematics::targetPoseCallback, this, std::placeholders::_1));\r\n\r\n    // Publisher for joint trajectory commands\r\n    joint_traj_pub_ = this->create_publisher<trajectory_msgs::msg::JointTrajectory>(\r\n      "/joint_trajectory", 10);\r\n\r\n    // Initialize KDL solvers\r\n    initializeKDL();\r\n\r\n    RCLCPP_INFO(this->get_logger(), "Isaac Inverse Kinematics initialized");\r\n  }\r\n\r\nprivate:\r\n  void jointStateCallback(const sensor_msgs::msg::JointState::SharedPtr msg)\r\n  {\r\n    // Store current joint positions\r\n    current_joint_positions_ = *msg;\r\n  }\r\n\r\n  void targetPoseCallback(const geometry_msgs::msg::PoseStamped::SharedPtr msg)\r\n  {\r\n    // Solve inverse kinematics for target pose\r\n    KDL::Frame target_frame;\r\n    target_frame.p.x(msg->pose.position.x);\r\n    target_frame.p.y(msg->pose.position.y);\r\n    target_frame.p.z(msg->pose.position.z);\r\n\r\n    target_frame.M = KDL::Rotation::Quaternion(\r\n      msg->pose.orientation.x,\r\n      msg->pose.orientation.y,\r\n      msg->pose.orientation.z,\r\n      msg->pose.orientation.w\r\n    );\r\n\r\n    // Solve IK\r\n    KDL::JntArray joint_positions;\r\n    if (solveIK(target_frame, joint_positions)) {\r\n      // Publish joint trajectory\r\n      publishJointTrajectory(joint_positions);\r\n    } else {\r\n      RCLCPP_WARN(this->get_logger(), "IK solution not found");\r\n    }\r\n  }\r\n\r\n  bool solveIK(const KDL::Frame & target_frame, KDL::JntArray & joint_positions)\r\n  {\r\n    // Initialize joint positions with current values\r\n    joint_positions.resize(chain_.getNrOfJoints());\r\n    for (size_t i = 0; i < current_joint_positions_.position.size() && i < joint_positions.rows(); ++i) {\r\n      joint_positions(i) = current_joint_positions_.position[i];\r\n    }\r\n\r\n    // Solve inverse kinematics\r\n    int result = ik_solver_->CartToJnt(joint_positions, target_frame, joint_positions);\r\n    return (result >= 0);\r\n  }\r\n\r\n  void publishJointTrajectory(const KDL::JntArray & joint_positions)\r\n  {\r\n    // Create trajectory message\r\n    trajectory_msgs::msg::JointTrajectory traj_msg;\r\n    traj_msg.joint_names = current_joint_positions_.name;\r\n\r\n    trajectory_msgs::msg::JointTrajectoryPoint point;\r\n    point.positions.resize(joint_positions.rows());\r\n    for (size_t i = 0; i < joint_positions.rows(); ++i) {\r\n      point.positions[i] = joint_positions(i);\r\n    }\r\n\r\n    // Set timing (1 second to reach target)\r\n    point.time_from_start.sec = 1;\r\n    point.time_from_start.nanosec = 0;\r\n\r\n    traj_msg.points.push_back(point);\r\n    traj_msg.header.stamp = this->get_clock()->now();\r\n    traj_msg.header.frame_id = "base_link";\r\n\r\n    joint_traj_pub_->publish(traj_msg);\r\n  }\r\n\r\n  void initializeKDL()\r\n  {\r\n    // Create a simple chain (this would be replaced with actual robot URDF)\r\n    // For example, a simple arm with 6 joints\r\n    chain_.addSegment(KDL::Segment("segment1",\r\n      KDL::Joint("joint1", KDL::Joint::RotZ),\r\n      KDL::Frame(KDL::Vector(0, 0, 0.1))));\r\n\r\n    chain_.addSegment(KDL::Segment("segment2",\r\n      KDL::Joint("joint2", KDL::Joint::RotY),\r\n      KDL::Frame(KDL::Vector(0, 0, 0.2))));\r\n\r\n    // Add more segments based on robot structure\r\n\r\n    // Create solvers\r\n    fk_solver_ = std::make_unique<KDL::ChainFkSolverPos_recursive>(chain_);\r\n    ik_solver_ = std::make_unique<KDL::ChainIkSolverPos_NR>(chain_, *fk_solver_, *ik_vel_solver_);\r\n  }\r\n\r\n  rclcpp::Subscription<sensor_msgs::msg::JointState>::SharedPtr joint_state_sub_;\r\n  rclcpp::Subscription<geometry_msgs::msg::PoseStamped>::SharedPtr target_pose_sub_;\r\n  rclcpp::Publisher<trajectory_msgs::msg::JointTrajectory>::SharedPtr joint_traj_pub_;\r\n\r\n  sensor_msgs::msg::JointState current_joint_positions_;\r\n\r\n  KDL::Chain chain_;\r\n  std::unique_ptr<KDL::ChainFkSolverPos> fk_solver_;\r\n  std::unique_ptr<KDL::ChainIkSolverVel> ik_vel_solver_;\r\n  std::unique_ptr<KDL::ChainIkSolverPos> ik_solver_;\r\n};\r\n\r\n}  // namespace control\r\n}  // namespace isaac_ros\r\n\r\n#include "rclcpp_components/register_node_macro.hpp"\r\nRCLCPP_COMPONENTS_REGISTER_NODE(isaac_ros::control::IsaacInverseKinematics)\n'})}),"\n",(0,i.jsx)(r.h3,{id:"trajectory-generation-techniques",children:"Trajectory Generation Techniques"}),"\n",(0,i.jsx)(r.p,{children:"Isaac implements various trajectory generation techniques:"}),"\n",(0,i.jsxs)(r.ul,{children:["\n",(0,i.jsxs)(r.li,{children:[(0,i.jsx)(r.strong,{children:"Polynomial Trajectories"}),": Smooth polynomial interpolation between waypoints"]}),"\n",(0,i.jsxs)(r.li,{children:[(0,i.jsx)(r.strong,{children:"Spline Trajectories"}),": Cubic and quintic spline generation"]}),"\n",(0,i.jsxs)(r.li,{children:[(0,i.jsx)(r.strong,{children:"Optimization-based"}),": Trajectory optimization considering constraints"]}),"\n",(0,i.jsxs)(r.li,{children:[(0,i.jsx)(r.strong,{children:"Real-time Generation"}),": Online trajectory generation for dynamic tasks"]}),"\n"]}),"\n",(0,i.jsx)(r.h3,{id:"smooth-motion-planning",children:"Smooth Motion Planning"}),"\n",(0,i.jsx)(r.p,{children:"Smooth motion planning is essential for humanoid robots to ensure stable and safe movement:"}),"\n",(0,i.jsx)(r.pre,{children:(0,i.jsx)(r.code,{className:"language-python",children:'# Example: Isaac smooth trajectory generation\r\nimport rclpy\r\nfrom rclpy.node import Node\r\nfrom trajectory_msgs.msg import JointTrajectory, JointTrajectoryPoint\r\nfrom sensor_msgs.msg import JointState\r\nfrom geometry_msgs.msg import PoseStamped\r\nimport numpy as np\r\nfrom scipy.interpolate import CubicSpline\r\nimport math\r\n\r\nclass IsaacTrajectoryGenerator(Node):\r\n    def __init__(self):\r\n        super().__init__(\'isaac_trajectory_generator\')\r\n\r\n        # Subscribers\r\n        self.joint_state_sub = self.create_subscription(\r\n            JointState, \'/joint_states\', self.joint_state_callback, 10)\r\n\r\n        self.trajectory_goal_sub = self.create_subscription(\r\n            JointState, \'/trajectory_goal\', self.trajectory_goal_callback, 10)\r\n\r\n        # Publishers\r\n        self.trajectory_pub = self.create_publisher(\r\n            JointTrajectory, \'/joint_trajectory\', 10)\r\n\r\n        # Initialize trajectory generation\r\n        self.initialize_trajectory_generation()\r\n\r\n        # Current state\r\n        self.current_joint_positions = {}\r\n        self.current_joint_velocities = {}\r\n        self.current_joint_accelerations = {}\r\n\r\n        # Trajectory parameters\r\n        self.max_velocity = 1.0  # rad/s\r\n        self.max_acceleration = 2.0  # rad/s^2\r\n        self.trajectory_duration = 2.0  # seconds\r\n\r\n    def initialize_trajectory_generation(self):\r\n        """Initialize Isaac\'s trajectory generation system"""\r\n        self.get_logger().info(\'Isaac Trajectory Generator initialized\')\r\n\r\n    def joint_state_callback(self, msg):\r\n        """Update current joint state"""\r\n        for i, name in enumerate(msg.name):\r\n            if i < len(msg.position):\r\n                self.current_joint_positions[name] = msg.position[i]\r\n            if i < len(msg.velocity):\r\n                self.current_joint_velocities[name] = msg.velocity[i]\r\n            if i < len(msg.effort):\r\n                self.current_joint_accelerations[name] = msg.effort[i]  # Simplified\r\n\r\n    def trajectory_goal_callback(self, msg):\r\n        """Generate trajectory to reach goal positions"""\r\n        # Create trajectory points\r\n        trajectory = self.generate_smooth_trajectory(msg)\r\n\r\n        # Publish trajectory\r\n        self.trajectory_pub.publish(trajectory)\r\n\r\n    def generate_smooth_trajectory(self, goal_state):\r\n        """Generate smooth trajectory using polynomial interpolation"""\r\n        # Get current and goal positions\r\n        current_positions = []\r\n        goal_positions = []\r\n        joint_names = []\r\n\r\n        for i, name in enumerate(goal_state.name):\r\n            joint_names.append(name)\r\n            goal_positions.append(goal_state.position[i])\r\n\r\n            # Get current position\r\n            if name in self.current_joint_positions:\r\n                current_positions.append(self.current_joint_positions[name])\r\n            else:\r\n                current_positions.append(0.0)  # Default if not found\r\n\r\n        # Generate time vector\r\n        dt = 0.01  # 100Hz\r\n        time_points = np.arange(0, self.trajectory_duration, dt)\r\n        n_points = len(time_points)\r\n\r\n        # Create trajectory message\r\n        traj_msg = JointTrajectory()\r\n        traj_msg.joint_names = joint_names\r\n        traj_msg.header.stamp = self.get_clock().now().to_msg()\r\n        traj_msg.header.frame_id = \'base_link\'\r\n\r\n        # Generate polynomial trajectory for each joint\r\n        for i in range(len(joint_names)):\r\n            # Cubic polynomial: q(t) = a0 + a1*t + a2*t^2 + a3*t^3\r\n            # Boundary conditions: q(0) = q_start, q(T) = q_goal, q_dot(0) = 0, q_dot(T) = 0\r\n            q_start = current_positions[i]\r\n            q_goal = goal_positions[i]\r\n            T = self.trajectory_duration\r\n\r\n            # Calculate polynomial coefficients\r\n            a0 = q_start\r\n            a1 = 0  # Initial velocity = 0\r\n            a2 = 3*(q_goal - q_start) / (T**2)\r\n            a3 = -2*(q_goal - q_start) / (T**3)\r\n\r\n            # Generate trajectory points\r\n            for j, t in enumerate(time_points):\r\n                # Position\r\n                pos = a0 + a1*t + a2*(t**2) + a3*(t**3)\r\n\r\n                # Velocity\r\n                vel = a1 + 2*a2*t + 3*a3*(t**2)\r\n\r\n                # Acceleration\r\n                acc = 2*a2 + 6*a3*t\r\n\r\n                # Create trajectory point if needed\r\n                if j < len(traj_msg.points):\r\n                    point = traj_msg.points[j]\r\n                else:\r\n                    point = JointTrajectoryPoint()\r\n                    traj_msg.points.append(point)\r\n\r\n                # Set position, velocity, and acceleration\r\n                point.positions.append(pos)\r\n                point.velocities.append(vel)\r\n                point.accelerations.append(acc)\r\n\r\n                # Set timing\r\n                point.time_from_start.sec = int(t)\r\n                point.time_from_start.nanosec = int((t - int(t)) * 1e9)\r\n\r\n        return traj_msg\r\n\r\n    def generate_minimal_jerk_trajectory(self, start_pos, goal_pos, duration):\r\n        """Generate minimal jerk trajectory"""\r\n        # Minimal jerk trajectory: q(t) = a0 + a1*t + a2*t^2 + a3*t^3 + a4*t^4 + a5*t^5\r\n        a0 = start_pos\r\n        a1 = 0  # Initial velocity\r\n        a2 = 0  # Initial acceleration\r\n        a3 = (20*(goal_pos - start_pos)) / (2 * duration**3)\r\n        a4 = (-30*(goal_pos - start_pos)) / (2 * duration**4)\r\n        a5 = (12*(goal_pos - start_pos)) / (2 * duration**5)\r\n\r\n        return a0, a1, a2, a3, a4, a5\n'})}),"\n",(0,i.jsx)(r.h2,{id:"balance-and-locomotion-control",children:"Balance and Locomotion Control"}),"\n",(0,i.jsx)(r.p,{children:"Balance and locomotion control are critical for humanoid robots, requiring sophisticated control algorithms to maintain stability while moving."}),"\n",(0,i.jsx)(r.h3,{id:"balance-control-systems-in-isaac",children:"Balance Control Systems in Isaac"}),"\n",(0,i.jsx)(r.p,{children:"Isaac provides advanced balance control systems:"}),"\n",(0,i.jsxs)(r.ul,{children:["\n",(0,i.jsxs)(r.li,{children:[(0,i.jsx)(r.strong,{children:"Zero Moment Point (ZMP) Control"}),": Classical approach for humanoid balance"]}),"\n",(0,i.jsxs)(r.li,{children:[(0,i.jsx)(r.strong,{children:"Linear Inverted Pendulum Model (LIPM)"}),": Simplified model for walking control"]}),"\n",(0,i.jsxs)(r.li,{children:[(0,i.jsx)(r.strong,{children:"Whole-Body Control"}),": Coordinated control of all robot joints"]}),"\n",(0,i.jsxs)(r.li,{children:[(0,i.jsx)(r.strong,{children:"Adaptive Balance"}),": Adjusting control parameters based on terrain"]}),"\n"]}),"\n",(0,i.jsx)(r.h3,{id:"locomotion-planning-for-humanoid-robots",children:"Locomotion Planning for Humanoid Robots"}),"\n",(0,i.jsx)(r.p,{children:"Locomotion planning in Isaac includes:"}),"\n",(0,i.jsxs)(r.ul,{children:["\n",(0,i.jsxs)(r.li,{children:[(0,i.jsx)(r.strong,{children:"Walking Pattern Generation"}),": Creating stable walking gaits"]}),"\n",(0,i.jsxs)(r.li,{children:[(0,i.jsx)(r.strong,{children:"Footstep Planning"}),": Computing optimal footstep locations"]}),"\n",(0,i.jsxs)(r.li,{children:[(0,i.jsx)(r.strong,{children:"Gait Adaptation"}),": Adjusting gait parameters for different terrains"]}),"\n",(0,i.jsxs)(r.li,{children:[(0,i.jsx)(r.strong,{children:"Stair Climbing"}),": Specialized locomotion for stairs and obstacles"]}),"\n"]}),"\n",(0,i.jsx)(r.pre,{children:(0,i.jsx)(r.code,{className:"language-python",children:'# Example: Isaac balance and locomotion control\r\nimport rclpy\r\nfrom rclpy.node import Node\r\nfrom sensor_msgs.msg import JointState, Imu\r\nfrom geometry_msgs.msg import Twist, Vector3\r\nfrom std_msgs.msg import Float64MultiArray\r\nimport numpy as np\r\nfrom scipy.spatial.transform import Rotation as R\r\n\r\nclass IsaacBalanceController(Node):\r\n    def __init__(self):\r\n        super().__init__(\'isaac_balance_controller\')\r\n\r\n        # Subscribers\r\n        self.joint_state_sub = self.create_subscription(\r\n            JointState, \'/joint_states\', self.joint_state_callback, 10)\r\n\r\n        self.imu_sub = self.create_subscription(\r\n            Imu, \'/imu/data\', self.imu_callback, 10)\r\n\r\n        self.cmd_vel_sub = self.create_subscription(\r\n            Twist, \'/cmd_vel\', self.cmd_vel_callback, 10)\r\n\r\n        # Publishers\r\n        self.joint_command_pub = self.create_publisher(\r\n            JointState, \'/joint_commands\', 10)\r\n\r\n        self.com_pub = self.create_publisher(\r\n            Vector3, \'/center_of_mass\', 10)\r\n\r\n        # Initialize balance controller\r\n        self.initialize_balance_controller()\r\n\r\n        # Robot state\r\n        self.joint_positions = {}\r\n        self.joint_velocities = {}\r\n        self.imu_orientation = None\r\n        self.imu_angular_velocity = None\r\n        self.imu_linear_acceleration = None\r\n\r\n        # Balance control parameters\r\n        self.com_position = np.array([0.0, 0.0, 0.8])  # Center of mass\r\n        self.com_velocity = np.array([0.0, 0.0, 0.0])\r\n        self.com_acceleration = np.array([0.0, 0.0, 0.0])\r\n\r\n        # Walking parameters\r\n        self.step_length = 0.3  # meters\r\n        self.step_width = 0.2  # meters\r\n        self.step_height = 0.05  # meters\r\n        self.walk_frequency = 1.0  # Hz\r\n\r\n        # Control gains\r\n        self.balance_kp = 100.0\r\n        self.balance_kd = 20.0\r\n\r\n        # Timer for control loop\r\n        self.control_timer = self.create_timer(0.01, self.control_callback)  # 100Hz\r\n\r\n    def initialize_balance_controller(self):\r\n        """Initialize Isaac\'s balance control system"""\r\n        self.get_logger().info(\'Isaac Balance Controller initialized\')\r\n\r\n    def joint_state_callback(self, msg):\r\n        """Update joint state"""\r\n        for i, name in enumerate(msg.name):\r\n            if i < len(msg.position):\r\n                self.joint_positions[name] = msg.position[i]\r\n            if i < len(msg.velocity):\r\n                self.joint_velocities[name] = msg.velocity[i]\r\n\r\n    def imu_callback(self, msg):\r\n        """Update IMU data"""\r\n        self.imu_orientation = np.array([\r\n            msg.orientation.x,\r\n            msg.orientation.y,\r\n            msg.orientation.z,\r\n            msg.orientation.w\r\n        ])\r\n\r\n        self.imu_angular_velocity = np.array([\r\n            msg.angular_velocity.x,\r\n            msg.angular_velocity.y,\r\n            msg.angular_velocity.z\r\n        ])\r\n\r\n        self.imu_linear_acceleration = np.array([\r\n            msg.linear_acceleration.x,\r\n            msg.linear_acceleration.y,\r\n            msg.linear_acceleration.z\r\n        ])\r\n\r\n    def cmd_vel_callback(self, msg):\r\n        """Handle velocity commands"""\r\n        self.desired_linear_vel = np.array([msg.linear.x, msg.linear.y, msg.linear.z])\r\n        self.desired_angular_vel = np.array([msg.angular.x, msg.angular.y, msg.angular.z])\r\n\r\n    def control_callback(self):\r\n        """Main control loop"""\r\n        # Update state estimation\r\n        self.update_state_estimation()\r\n\r\n        # Compute balance control\r\n        balance_commands = self.compute_balance_control()\r\n\r\n        # Compute walking pattern if moving\r\n        walking_commands = self.compute_walking_pattern()\r\n\r\n        # Combine commands\r\n        final_commands = self.combine_commands(balance_commands, walking_commands)\r\n\r\n        # Publish commands\r\n        self.publish_joint_commands(final_commands)\r\n\r\n    def update_state_estimation(self):\r\n        """Update robot state estimation"""\r\n        # This would involve more sophisticated state estimation\r\n        # For now, we\'ll use simplified estimation\r\n        pass\r\n\r\n    def compute_balance_control(self):\r\n        """Compute balance control commands"""\r\n        # Simple PD control for balance\r\n        # In practice, this would use more sophisticated approaches like ZMP control\r\n\r\n        # Get current orientation error\r\n        if self.imu_orientation is not None:\r\n            # Convert quaternion to Euler angles for simple control\r\n            rot = R.from_quat(self.imu_orientation)\r\n            euler_angles = rot.as_euler(\'xyz\')\r\n\r\n            # Compute control torques based on orientation error\r\n            orientation_error = euler_angles\r\n            control_torques = -self.balance_kp * orientation_error[:2] - self.balance_kd * self.imu_angular_velocity[:2]\r\n\r\n            return control_torques\r\n        else:\r\n            return np.array([0.0, 0.0])\r\n\r\n    def compute_walking_pattern(self):\r\n        """Compute walking pattern based on desired velocity"""\r\n        # This would generate footstep locations and timing\r\n        # For now, we\'ll return a simple walking pattern\r\n        return np.array([0.0, 0.0])\r\n\r\n    def combine_commands(self, balance_commands, walking_commands):\r\n        """Combine balance and walking commands"""\r\n        # In practice, this would involve more sophisticated integration\r\n        # For now, we\'ll simply add them\r\n        return balance_commands + walking_commands\r\n\r\n    def publish_joint_commands(self, commands):\r\n        """Publish joint commands"""\r\n        joint_cmd = JointState()\r\n        joint_cmd.header.stamp = self.get_clock().now().to_msg()\r\n        joint_cmd.header.frame_id = \'base_link\'\r\n\r\n        # Set joint names (this would match your robot\'s joint names)\r\n        joint_cmd.name = [\'left_hip_joint\', \'right_hip_joint\', \'left_knee_joint\', \'right_knee_joint\']\r\n\r\n        # Set positions based on computed commands\r\n        # This is simplified - in practice, you\'d map commands to specific joints\r\n        joint_cmd.position = [0.0, 0.0, 0.0, 0.0]  # Placeholder values\r\n\r\n        self.joint_command_pub.publish(joint_cmd)\r\n\r\n        # Publish center of mass for visualization\r\n        com_msg = Vector3()\r\n        com_msg.x = float(self.com_position[0])\r\n        com_msg.y = float(self.com_position[1])\r\n        com_msg.z = float(self.com_position[2])\r\n        self.com_pub.publish(com_msg)\n'})}),"\n",(0,i.jsx)(r.h3,{id:"walking-and-standing-stability",children:"Walking and Standing Stability"}),"\n",(0,i.jsx)(r.p,{children:"Isaac provides tools for maintaining walking and standing stability:"}),"\n",(0,i.jsxs)(r.ul,{children:["\n",(0,i.jsxs)(r.li,{children:[(0,i.jsx)(r.strong,{children:"Capture Point Control"}),": Predictive control for dynamic balance"]}),"\n",(0,i.jsxs)(r.li,{children:[(0,i.jsx)(r.strong,{children:"Stance Control"}),": Managing single and double support phases"]}),"\n",(0,i.jsxs)(r.li,{children:[(0,i.jsx)(r.strong,{children:"Disturbance Rejection"}),": Handling external disturbances"]}),"\n",(0,i.jsxs)(r.li,{children:[(0,i.jsx)(r.strong,{children:"Recovery Strategies"}),": Automatic recovery from balance loss"]}),"\n"]}),"\n",(0,i.jsx)(r.h2,{id:"manipulation-and-grasping-controllers",children:"Manipulation and Grasping Controllers"}),"\n",(0,i.jsx)(r.p,{children:"Manipulation and grasping are essential capabilities for humanoid robots, enabling interaction with objects in their environment."}),"\n",(0,i.jsx)(r.h3,{id:"manipulation-control-in-isaac",children:"Manipulation Control in Isaac"}),"\n",(0,i.jsx)(r.p,{children:"Isaac's manipulation control system includes:"}),"\n",(0,i.jsxs)(r.ul,{children:["\n",(0,i.jsxs)(r.li,{children:[(0,i.jsx)(r.strong,{children:"Cartesian Control"}),": Controlling end-effector position and orientation"]}),"\n",(0,i.jsxs)(r.li,{children:[(0,i.jsx)(r.strong,{children:"Force Control"}),": Controlling interaction forces with objects"]}),"\n",(0,i.jsxs)(r.li,{children:[(0,i.jsx)(r.strong,{children:"Impedance Control"}),": Controlling robot compliance"]}),"\n",(0,i.jsxs)(r.li,{children:[(0,i.jsx)(r.strong,{children:"Grasp Planning"}),": Planning stable grasps for objects"]}),"\n"]}),"\n",(0,i.jsx)(r.h3,{id:"grasping-algorithms-and-planning",children:"Grasping Algorithms and Planning"}),"\n",(0,i.jsx)(r.p,{children:"Isaac provides sophisticated grasping capabilities:"}),"\n",(0,i.jsxs)(r.ul,{children:["\n",(0,i.jsxs)(r.li,{children:[(0,i.jsx)(r.strong,{children:"Geometric Grasping"}),": Grasps based on object geometry"]}),"\n",(0,i.jsxs)(r.li,{children:[(0,i.jsx)(r.strong,{children:"Learning-based Grasping"}),": AI-powered grasp prediction"]}),"\n",(0,i.jsxs)(r.li,{children:[(0,i.jsx)(r.strong,{children:"Multi-finger Grasping"}),": Coordinated control of multiple fingers"]}),"\n",(0,i.jsxs)(r.li,{children:[(0,i.jsx)(r.strong,{children:"Adaptive Grasping"}),": Adjusting grasp based on object properties"]}),"\n"]}),"\n",(0,i.jsx)(r.pre,{children:(0,i.jsx)(r.code,{className:"language-cpp",children:'// Example: Isaac manipulation and grasping controller\r\n#include "rclcpp/rclcpp.hpp"\r\n#include "sensor_msgs/msg/joint_state.hpp"\r\n#include "geometry_msgs/msg/pose_stamped.hpp"\r\n#include "geometry_msgs/msg/wrench_stamped.hpp"\r\n#include "control_msgs/msg/gripper_command.hpp"\r\n#include "trajectory_msgs/msg/joint_trajectory.hpp"\r\n#include <tf2_ros/transform_listener.h>\r\n#include <tf2_geometry_msgs/tf2_geometry_msgs.h>\r\n\r\nnamespace isaac_ros\r\n{\r\nnamespace manipulation\r\n{\r\n\r\nclass IsaacManipulationController : public rclcpp::Node\r\n{\r\npublic:\r\n  explicit IsaacManipulationController(const rclcpp::NodeOptions & options)\r\n  : Node("isaac_manipulation_controller", options), tf_buffer_(this->get_clock())\r\n  {\r\n    // Subscribers\r\n    joint_state_sub_ = this->create_subscription<sensor_msgs::msg::JointState>(\r\n      "/joint_states", 10,\r\n      std::bind(&IsaacManipulationController::jointStateCallback, this, std::placeholders::_1));\r\n\r\n    target_pose_sub_ = this->create_subscription<geometry_msgs::msg::PoseStamped>(\r\n      "/manipulation_target", 10,\r\n      std::bind(&IsaacManipulationController::targetPoseCallback, this, std::placeholders::_1));\r\n\r\n    force_torque_sub_ = this->create_subscription<geometry_msgs::msg::WrenchStamped>(\r\n      "/wrench", 10,\r\n      std::bind(&IsaacManipulationController::forceTorqueCallback, this, std::placeholders::_1));\r\n\r\n    // Publishers\r\n    joint_traj_pub_ = this->create_publisher<trajectory_msgs::msg::JointTrajectory>(\r\n      "/arm_controller/joint_trajectory", 10);\r\n\r\n    gripper_cmd_pub_ = this->create_publisher<control_msgs::msg::GripperCommand>(\r\n      "/gripper_command", 10);\r\n\r\n    // Initialize TF listener\r\n    tf_listener_ = std::make_shared<tf2_ros::TransformListener>(tf_buffer_);\r\n\r\n    RCLCPP_INFO(this->get_logger(), "Isaac Manipulation Controller initialized");\r\n  }\r\n\r\nprivate:\r\n  void jointStateCallback(const sensor_msgs::msg::JointState::SharedPtr msg)\r\n  {\r\n    // Store current joint state\r\n    current_joint_state_ = *msg;\r\n  }\r\n\r\n  void targetPoseCallback(const geometry_msgs::msg::PoseStamped::SharedPtr msg)\r\n  {\r\n    // Plan and execute manipulation to target pose\r\n    if (planManipulationToPose(*msg)) {\r\n      executeManipulationPlan();\r\n    }\r\n  }\r\n\r\n  void forceTorqueCallback(const geometry_msgs::msg::WrenchStamped::SharedPtr msg)\r\n  {\r\n    // Store force/torque information for compliant control\r\n    current_wrench_ = *msg;\r\n  }\r\n\r\n  bool planManipulationToPose(const geometry_msgs::msg::PoseStamped & target_pose)\r\n  {\r\n    // Plan manipulation trajectory using Isaac\'s motion planning\r\n    // This would involve inverse kinematics and collision checking\r\n\r\n    // For now, we\'ll create a simple trajectory\r\n    trajectory_msgs::msg::JointTrajectory traj;\r\n    traj.joint_names = {"shoulder_pan_joint", "shoulder_lift_joint",\r\n                       "elbow_joint", "wrist_1_joint", "wrist_2_joint", "wrist_3_joint"};\r\n\r\n    // Create trajectory point\r\n    trajectory_msgs::msg::JointTrajectoryPoint point;\r\n    // This would be computed based on IK solution to reach target_pose\r\n    point.positions = {0.0, -1.57, 0.0, -1.57, 0.0, 0.0};  // Placeholder\r\n    point.velocities = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0};\r\n    point.accelerations = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0};\r\n    point.time_from_start.sec = 2;\r\n    point.time_from_start.nanosec = 0;\r\n\r\n    traj.points.push_back(point);\r\n    manipulation_trajectory_ = traj;\r\n\r\n    return true;\r\n  }\r\n\r\n  void executeManipulationPlan()\r\n  {\r\n    // Execute the planned manipulation trajectory\r\n    joint_traj_pub_->publish(manipulation_trajectory_);\r\n  }\r\n\r\n  void executeGrasp(const std::string & object_name)\r\n  {\r\n    // Execute grasp for specified object\r\n    control_msgs::msg::GripperCommand gripper_cmd;\r\n    gripper_cmd.position = 0.0;  // Fully closed for grasping\r\n    gripper_cmd.max_effort = 100.0;  // Maximum effort\r\n\r\n    gripper_cmd_pub_->publish(gripper_cmd);\r\n  }\r\n\r\n  rclcpp::Subscription<sensor_msgs::msg::JointState>::SharedPtr joint_state_sub_;\r\n  rclcpp::Subscription<geometry_msgs::msg::PoseStamped>::SharedPtr target_pose_sub_;\r\n  rclcpp::Subscription<geometry_msgs::msg::WrenchStamped>::SharedPtr force_torque_sub_;\r\n\r\n  rclcpp::Publisher<trajectory_msgs::msg::JointTrajectory>::SharedPtr joint_traj_pub_;\r\n  rclcpp::Publisher<control_msgs::msg::GripperCommand>::SharedPtr gripper_cmd_pub_;\r\n\r\n  sensor_msgs::msg::JointState current_joint_state_;\r\n  geometry_msgs::msg::WrenchStamped current_wrench_;\r\n  trajectory_msgs::msg::JointTrajectory manipulation_trajectory_;\r\n\r\n  tf2_ros::Buffer tf_buffer_;\r\n  std::shared_ptr<tf2_ros::TransformListener> tf_listener_;\r\n};\r\n\r\n}  // namespace manipulation\r\n}  // namespace isaac_ros\r\n\r\n#include "rclcpp_components/register_node_macro.hpp"\r\nRCLCPP_COMPONENTS_REGISTER_NODE(isaac_ros::manipulation::IsaacManipulationController)\n'})}),"\n",(0,i.jsx)(r.h3,{id:"end-effector-control",children:"End-effector Control"}),"\n",(0,i.jsx)(r.p,{children:"Isaac provides precise end-effector control:"}),"\n",(0,i.jsxs)(r.ul,{children:["\n",(0,i.jsxs)(r.li,{children:[(0,i.jsx)(r.strong,{children:"Cartesian Impedance Control"}),": Controlling end-effector compliance"]}),"\n",(0,i.jsxs)(r.li,{children:[(0,i.jsx)(r.strong,{children:"Force Control"}),": Regulating interaction forces"]}),"\n",(0,i.jsxs)(r.li,{children:[(0,i.jsx)(r.strong,{children:"Admittance Control"}),": Controlling robot response to external forces"]}),"\n",(0,i.jsxs)(r.li,{children:[(0,i.jsx)(r.strong,{children:"Trajectory Following"}),": Precise end-effector trajectory tracking"]}),"\n"]}),"\n",(0,i.jsx)(r.h2,{id:"adaptive-control-systems",children:"Adaptive Control Systems"}),"\n",(0,i.jsx)(r.p,{children:"Adaptive control is crucial for humanoid robots operating in uncertain and changing environments."}),"\n",(0,i.jsx)(r.h3,{id:"adaptive-control-concepts",children:"Adaptive Control Concepts"}),"\n",(0,i.jsx)(r.p,{children:"Isaac's adaptive control system includes:"}),"\n",(0,i.jsxs)(r.ul,{children:["\n",(0,i.jsxs)(r.li,{children:[(0,i.jsx)(r.strong,{children:"Parameter Estimation"}),": Estimating unknown system parameters"]}),"\n",(0,i.jsxs)(r.li,{children:[(0,i.jsx)(r.strong,{children:"Gain Scheduling"}),": Adjusting control gains based on operating conditions"]}),"\n",(0,i.jsxs)(r.li,{children:[(0,i.jsx)(r.strong,{children:"Model Reference Adaptive Control"}),": Adapting to match a reference model"]}),"\n",(0,i.jsxs)(r.li,{children:[(0,i.jsx)(r.strong,{children:"Self-Organizing Maps"}),": Learning control strategies"]}),"\n"]}),"\n",(0,i.jsx)(r.h3,{id:"learning-based-control-approaches",children:"Learning-based Control Approaches"}),"\n",(0,i.jsx)(r.p,{children:"Isaac integrates machine learning for adaptive control:"}),"\n",(0,i.jsxs)(r.ul,{children:["\n",(0,i.jsxs)(r.li,{children:[(0,i.jsx)(r.strong,{children:"Neural Network Controllers"}),": Learning complex control mappings"]}),"\n",(0,i.jsxs)(r.li,{children:[(0,i.jsx)(r.strong,{children:"Reinforcement Learning"}),": Learning optimal control policies"]}),"\n",(0,i.jsxs)(r.li,{children:[(0,i.jsx)(r.strong,{children:"Online Learning"}),": Adapting to new conditions in real-time"]}),"\n",(0,i.jsxs)(r.li,{children:[(0,i.jsx)(r.strong,{children:"Transfer Learning"}),": Applying learned behaviors to new tasks"]}),"\n"]}),"\n",(0,i.jsx)(r.h3,{id:"real-time-adaptation-techniques",children:"Real-time Adaptation Techniques"}),"\n",(0,i.jsx)(r.pre,{children:(0,i.jsx)(r.code,{className:"language-python",children:'# Example: Isaac adaptive control system\r\nimport rclpy\r\nfrom rclpy.node import Node\r\nfrom sensor_msgs.msg import JointState, Imu\r\nfrom geometry_msgs.msg import Twist, WrenchStamped\r\nfrom std_msgs.msg import Float64MultiArray\r\nimport numpy as np\r\nfrom sklearn.linear_model import SGDRegressor\r\nimport threading\r\nimport time\r\n\r\nclass IsaacAdaptiveController(Node):\r\n    def __init__(self):\r\n        super().__init__(\'isaac_adaptive_controller\')\r\n\r\n        # Subscribers\r\n        self.joint_state_sub = self.create_subscription(\r\n            JointState, \'/joint_states\', self.joint_state_callback, 10)\r\n\r\n        self.imu_sub = self.create_subscription(\r\n            Imu, \'/imu/data\', self.imu_callback, 10)\r\n\r\n        self.wrench_sub = self.create_subscription(\r\n            WrenchStamped, \'/wrench\', self.wrench_callback, 10)\r\n\r\n        self.command_sub = self.create_subscription(\r\n            Twist, \'/cmd_vel\', self.command_callback, 10)\r\n\r\n        # Publishers\r\n        self.control_output_pub = self.create_publisher(\r\n            JointState, \'/adaptive_control_commands\', 10)\r\n\r\n        self.adaptation_params_pub = self.create_publisher(\r\n            Float64MultiArray, \'/adaptation_parameters\', 10)\r\n\r\n        # Initialize adaptive controller\r\n        self.initialize_adaptive_controller()\r\n\r\n        # Robot state\r\n        self.joint_positions = {}\r\n        self.joint_velocities = {}\r\n        self.imu_data = None\r\n        self.wrench_data = None\r\n        self.command_input = None\r\n\r\n        # Adaptive control parameters\r\n        self.base_controller_gains = {\'kp\': 100.0, \'ki\': 10.0, \'kd\': 20.0}\r\n        self.adaptive_gains = {\'kp\': 0.0, \'ki\': 0.0, \'kd\': 0.0}\r\n        self.error_history = []\r\n        self.max_history = 100\r\n\r\n        # Machine learning model for adaptation\r\n        self.adaptation_model = SGDRegressor(\r\n            learning_rate=\'adaptive\',\r\n            eta0=0.01,\r\n            max_iter=1000\r\n        )\r\n        self.model_trained = False\r\n\r\n        # Lock for thread safety\r\n        self.data_lock = threading.RLock()\r\n\r\n        # Timer for control loop\r\n        self.control_timer = self.create_timer(0.01, self.control_callback)  # 100Hz\r\n        self.adaptation_timer = self.create_timer(1.0, self.adaptation_callback)  # 1Hz adaptation\r\n\r\n    def initialize_adaptive_controller(self):\r\n        """Initialize Isaac\'s adaptive control system"""\r\n        self.get_logger().info(\'Isaac Adaptive Controller initialized\')\r\n\r\n    def joint_state_callback(self, msg):\r\n        """Update joint state"""\r\n        with self.data_lock:\r\n            for i, name in enumerate(msg.name):\r\n                if i < len(msg.position):\r\n                    self.joint_positions[name] = msg.position[i]\r\n                if i < len(msg.velocity):\r\n                    self.joint_velocities[name] = msg.velocity[i]\r\n\r\n    def imu_callback(self, msg):\r\n        """Update IMU data"""\r\n        with self.data_lock:\r\n            self.imu_data = msg\r\n\r\n    def wrench_callback(self, msg):\r\n        """Update wrench data"""\r\n        with self.data_lock:\r\n            self.wrench_data = msg\r\n\r\n    def command_callback(self, msg):\r\n        """Update command input"""\r\n        with self.data_lock:\r\n            self.command_input = msg\r\n\r\n    def control_callback(self):\r\n        """Main control loop with adaptation"""\r\n        with self.data_lock:\r\n            # Calculate control output with adaptive gains\r\n            control_output = self.compute_adaptive_control()\r\n\r\n            # Publish control commands\r\n            self.publish_control_output(control_output)\r\n\r\n    def adaptation_callback(self):\r\n        """Adaptation loop - runs less frequently"""\r\n        with self.data_lock:\r\n            # Update adaptation parameters based on performance\r\n            self.update_adaptation_parameters()\r\n\r\n            # Publish adaptation parameters for monitoring\r\n            self.publish_adaptation_params()\r\n\r\n    def compute_adaptive_control(self):\r\n        """Compute control output using adaptive parameters"""\r\n        # Get current state\r\n        current_pos = list(self.joint_positions.values()) if self.joint_positions else [0.0] * 6\r\n        current_vel = list(self.joint_velocities.values()) if self.joint_velocities else [0.0] * 6\r\n\r\n        # Calculate error (simplified - would be based on desired vs actual)\r\n        error = [0.1] * len(current_pos)  # Placeholder\r\n\r\n        # Update error history\r\n        self.error_history.append(np.mean(np.abs(error)))\r\n        if len(self.error_history) > self.max_history:\r\n            self.error_history.pop(0)\r\n\r\n        # Calculate control output using PID with adaptive gains\r\n        control_output = JointState()\r\n        control_output.name = list(self.joint_positions.keys()) if self.joint_positions else [f\'joint_{i}\' for i in range(6)]\r\n        control_output.position = [0.0] * len(control_output.name)\r\n        control_output.velocity = [0.0] * len(control_output.name)\r\n        control_output.effort = [0.0] * len(control_output.name)\r\n\r\n        # Apply PID control with adaptive gains\r\n        for i in range(min(len(control_output.effort), len(error))):\r\n            # Proportional term\r\n            kp_total = self.base_controller_gains[\'kp\'] + self.adaptive_gains[\'kp\']\r\n            p_term = kp_total * error[i]\r\n\r\n            # Derivative term (simplified)\r\n            d_term = 0.0\r\n            if len(self.error_history) > 1:\r\n                d_error = self.error_history[-1] - self.error_history[-2]\r\n                kd_total = self.base_controller_gains[\'kd\'] + self.adaptive_gains[\'kd\']\r\n                d_term = kd_total * d_error\r\n\r\n            # Total control output\r\n            control_output.effort[i] = p_term + d_term\r\n\r\n        return control_output\r\n\r\n    def update_adaptation_parameters(self):\r\n        """Update adaptation parameters based on performance"""\r\n        if len(self.error_history) < 10:\r\n            return\r\n\r\n        # Calculate performance metrics\r\n        recent_error = np.mean(self.error_history[-10:])\r\n        historical_error = np.mean(self.error_history[:-10]) if len(self.error_history) > 10 else recent_error\r\n\r\n        # Adjust adaptive gains based on performance\r\n        error_improvement = historical_error - recent_error\r\n\r\n        # If performance is degrading, increase adaptation\r\n        if error_improvement < 0:\r\n            self.adaptive_gains[\'kp\'] += 0.1\r\n            self.adaptive_gains[\'kd\'] += 0.05\r\n        else:\r\n            # If improving, reduce adaptation rate to stabilize\r\n            self.adaptive_gains[\'kp\'] *= 0.99\r\n            self.adaptive_gains[\'kd\'] *= 0.99\r\n\r\n        # Constrain gains to reasonable bounds\r\n        self.adaptive_gains[\'kp\'] = np.clip(self.adaptive_gains[\'kp\'], -50, 50)\r\n        self.adaptive_gains[\'kd\'] = np.clip(self.adaptive_gains[\'kd\'], -20, 20)\r\n\r\n        self.get_logger().debug(f\'Adaptive gains updated - KP: {self.adaptive_gains["kp"]:.3f}, KD: {self.adaptive_gains["kd"]:.3f}\')\r\n\r\n    def publish_control_output(self, control_output):\r\n        """Publish control output"""\r\n        control_output.header.stamp = self.get_clock().now().to_msg()\r\n        control_output.header.frame_id = \'base_link\'\r\n        self.control_output_pub.publish(control_output)\r\n\r\n    def publish_adaptation_params(self):\r\n        """Publish adaptation parameters for monitoring"""\r\n        params_msg = Float64MultiArray()\r\n        params_msg.data = [\r\n            self.adaptive_gains[\'kp\'],\r\n            self.adaptive_gains[\'ki\'],\r\n            self.adaptive_gains[\'kd\'],\r\n            np.mean(self.error_history) if self.error_history else 0.0\r\n        ]\r\n        self.adaptation_params_pub.publish(params_msg)\n'})}),"\n",(0,i.jsx)(r.h3,{id:"safety-and-stability-considerations",children:"Safety and Stability Considerations"}),"\n",(0,i.jsx)(r.p,{children:"Adaptive control systems must maintain safety and stability:"}),"\n",(0,i.jsxs)(r.ul,{children:["\n",(0,i.jsxs)(r.li,{children:[(0,i.jsx)(r.strong,{children:"Stability Guarantees"}),": Ensuring adaptive systems remain stable"]}),"\n",(0,i.jsxs)(r.li,{children:[(0,i.jsx)(r.strong,{children:"Safety Bounds"}),": Limiting adaptive parameter changes"]}),"\n",(0,i.jsxs)(r.li,{children:[(0,i.jsx)(r.strong,{children:"Fallback Controllers"}),": Maintaining basic functionality if adaptation fails"]}),"\n",(0,i.jsxs)(r.li,{children:[(0,i.jsx)(r.strong,{children:"Monitoring"}),": Continuously monitoring adaptation performance"]}),"\n"]}),"\n",(0,i.jsx)(r.h2,{id:"conclusion",children:"Conclusion"}),"\n",(0,i.jsx)(r.p,{children:"Isaac's control systems and motion planning capabilities provide a comprehensive foundation for humanoid robot control. The platform's integration of motion planning algorithms, inverse kinematics, balance control, manipulation, and adaptive control creates a powerful system for developing intelligent robotic behaviors. These control systems are optimized for real-time performance using GPU acceleration, making them suitable for complex humanoid robots that require sophisticated control strategies to operate safely and effectively in dynamic environments."})]})}function d(n={}){const{wrapper:r}={...(0,o.R)(),...n.components};return r?(0,i.jsx)(r,{...n,children:(0,i.jsx)(p,{...n})}):p(n)}},8453(n,r,e){e.d(r,{R:()=>a,x:()=>s});var t=e(6540);const i={},o=t.createContext(i);function a(n){const r=t.useContext(o);return t.useMemo(function(){return"function"==typeof n?n(r):{...r,...n}},[r,n])}function s(n){let r;return r=n.disableParentContext?"function"==typeof n.components?n.components(i):n.components||i:a(n.components),t.createElement(o.Provider,{value:r},n.children)}}}]);