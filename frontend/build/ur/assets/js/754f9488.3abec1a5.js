"use strict";(globalThis.webpackChunkphysical_ai_textbook=globalThis.webpackChunkphysical_ai_textbook||[]).push([[9354],{8453(e,i,n){n.d(i,{R:()=>o,x:()=>l});var s=n(6540);const t={},r=s.createContext(t);function o(e){const i=s.useContext(r);return s.useMemo(function(){return"function"==typeof e?e(i):{...i,...e}},[i,e])}function l(e){let i;return i=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:o(e.components),s.createElement(r.Provider,{value:i},e.children)}},9759(e,i,n){n.r(i),n.d(i,{assets:()=>a,contentTitle:()=>l,default:()=>h,frontMatter:()=>o,metadata:()=>s,toc:()=>c});const s=JSON.parse('{"id":"module-2-exercises-assignments","title":"Chapter 8 - Exercises and Assignments","description":"Chapter 1 Exercises: Digital Twin Concepts and Applications","source":"@site/docs/module-2-exercises-assignments.md","sourceDirName":".","slug":"/module-2-exercises-assignments","permalink":"/ur/docs/module-2-exercises-assignments","draft":false,"unlisted":false,"editUrl":"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/module-2-exercises-assignments.md","tags":[],"version":"current","frontMatter":{"id":"module-2-exercises-assignments","title":"Chapter 8 - Exercises and Assignments","sidebar_label":"Chapter 8 - Exercises and Assignments"},"sidebar":"tutorialSidebar","previous":{"title":"Chapter 7 - Integration with ROS2","permalink":"/ur/docs/module-2-ros2-integration"},"next":{"title":"Chapter 1 - NVIDIA Isaac Platform Overview","permalink":"/ur/docs/module-3-isaac-overview"}}');var t=n(4848),r=n(8453);const o={id:"module-2-exercises-assignments",title:"Chapter 8 - Exercises and Assignments",sidebar_label:"Chapter 8 - Exercises and Assignments"},l="Chapter 8: Exercises and Assignments",a={},c=[{value:"Chapter 1 Exercises: Digital Twin Concepts and Applications",id:"chapter-1-exercises-digital-twin-concepts-and-applications",level:2},{value:"Exercise 1.1: Digital Twin Architecture Analysis",id:"exercise-11-digital-twin-architecture-analysis",level:3},{value:"Exercise 1.2: Simulation vs. Digital Twin Comparison",id:"exercise-12-simulation-vs-digital-twin-comparison",level:3},{value:"Exercise 1.3: Digital Twin Application Scenarios",id:"exercise-13-digital-twin-application-scenarios",level:3},{value:"Chapter 2 Exercises: Gazebo Simulation Environment",id:"chapter-2-exercises-gazebo-simulation-environment",level:2},{value:"Exercise 2.1: Gazebo Environment Setup",id:"exercise-21-gazebo-environment-setup",level:3},{value:"Exercise 2.2: Custom World Creation",id:"exercise-22-custom-world-creation",level:3},{value:"Exercise 2.3: Robot Model Integration",id:"exercise-23-robot-model-integration",level:3},{value:"Chapter 3 Exercises: Unity Simulation Environment",id:"chapter-3-exercises-unity-simulation-environment",level:2},{value:"Exercise 3.1: Unity Robotics Setup",id:"exercise-31-unity-robotics-setup",level:3},{value:"Exercise 3.2: Robot Model Import and Configuration",id:"exercise-32-robot-model-import-and-configuration",level:3},{value:"Exercise 3.3: Environment Creation",id:"exercise-33-environment-creation",level:3},{value:"Chapter 4 Exercises: Robot Modeling and Physics",id:"chapter-4-exercises-robot-modeling-and-physics",level:2},{value:"Exercise 4.1: URDF Model Development",id:"exercise-41-urdf-model-development",level:3},{value:"Exercise 4.2: Physics Parameter Tuning",id:"exercise-42-physics-parameter-tuning",level:3},{value:"Exercise 4.3: Unity Physics Configuration",id:"exercise-43-unity-physics-configuration",level:3},{value:"Chapter 5 Exercises: Sensor Simulation and Integration",id:"chapter-5-exercises-sensor-simulation-and-integration",level:2},{value:"Exercise 5.1: Camera Sensor Integration",id:"exercise-51-camera-sensor-integration",level:3},{value:"Exercise 5.2: LIDAR Sensor Implementation",id:"exercise-52-lidar-sensor-implementation",level:3},{value:"Exercise 5.3: Multi-Sensor Fusion",id:"exercise-53-multi-sensor-fusion",level:3},{value:"Chapter 6 Exercises: Virtual Testing and Validation",id:"chapter-6-exercises-virtual-testing-and-validation",level:2},{value:"Exercise 6.1: Test Scenario Development",id:"exercise-61-test-scenario-development",level:3},{value:"Exercise 6.2: Automated Testing Framework",id:"exercise-62-automated-testing-framework",level:3},{value:"Exercise 6.3: Performance Evaluation",id:"exercise-63-performance-evaluation",level:3},{value:"Chapter 7 Exercises: Integration with ROS2",id:"chapter-7-exercises-integration-with-ros2",level:2},{value:"Exercise 7.1: ROS2-Gazebo Integration",id:"exercise-71-ros2-gazebo-integration",level:3},{value:"Exercise 7.2: ROS2-Unity Integration",id:"exercise-72-ros2-unity-integration",level:3},{value:"Exercise 7.3: Cross-Environment Integration",id:"exercise-73-cross-environment-integration",level:3},{value:"Comprehensive Assignment: Complete Digital Twin System",id:"comprehensive-assignment-complete-digital-twin-system",level:2},{value:"Assignment Overview",id:"assignment-overview",level:3},{value:"Requirements",id:"requirements",level:3},{value:"Implementation Tasks",id:"implementation-tasks",level:3},{value:"Deliverables",id:"deliverables",level:3},{value:"Evaluation Criteria",id:"evaluation-criteria",level:3},{value:"Solutions and Assessment Rubric",id:"solutions-and-assessment-rubric",level:2},{value:"Chapter 1 Solutions",id:"chapter-1-solutions",level:3},{value:"Chapter 2 Solutions",id:"chapter-2-solutions",level:3},{value:"Chapter 3 Solutions",id:"chapter-3-solutions",level:3},{value:"Assessment Rubric",id:"assessment-rubric",level:3}];function d(e){const i={h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,r.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(i.header,{children:(0,t.jsx)(i.h1,{id:"chapter-8-exercises-and-assignments",children:"Chapter 8: Exercises and Assignments"})}),"\n",(0,t.jsx)(i.h2,{id:"chapter-1-exercises-digital-twin-concepts-and-applications",children:"Chapter 1 Exercises: Digital Twin Concepts and Applications"}),"\n",(0,t.jsx)(i.h3,{id:"exercise-11-digital-twin-architecture-analysis",children:"Exercise 1.1: Digital Twin Architecture Analysis"}),"\n",(0,t.jsxs)(i.p,{children:[(0,t.jsx)(i.strong,{children:"Objective"}),": Understand the components and architecture of a digital twin system."]}),"\n",(0,t.jsxs)(i.p,{children:[(0,t.jsx)(i.strong,{children:"Task"}),": Analyze a real-world humanoid robot system (e.g., Honda ASIMO, Boston Dynamics Atlas, or NASA Robonaut 2) and identify the following components of its potential digital twin:"]}),"\n",(0,t.jsxs)(i.ol,{children:["\n",(0,t.jsx)(i.li,{children:"Physical system components"}),"\n",(0,t.jsx)(i.li,{children:"Data acquisition layer"}),"\n",(0,t.jsx)(i.li,{children:"Communication infrastructure"}),"\n",(0,t.jsx)(i.li,{children:"Virtual model components"}),"\n",(0,t.jsx)(i.li,{children:"Analysis and optimization engine"}),"\n",(0,t.jsx)(i.li,{children:"Visualization interface"}),"\n"]}),"\n",(0,t.jsxs)(i.p,{children:[(0,t.jsx)(i.strong,{children:"Deliverable"}),": Create a diagram showing the digital twin architecture with labeled components and data flow directions."]}),"\n",(0,t.jsx)(i.h3,{id:"exercise-12-simulation-vs-digital-twin-comparison",children:"Exercise 1.2: Simulation vs. Digital Twin Comparison"}),"\n",(0,t.jsxs)(i.p,{children:[(0,t.jsx)(i.strong,{children:"Objective"}),": Distinguish between traditional simulation and digital twin systems."]}),"\n",(0,t.jsxs)(i.p,{children:[(0,t.jsx)(i.strong,{children:"Task"}),": Create a comparison table highlighting the differences between traditional simulation and digital twin approaches for humanoid robotics, including at least 5 different criteria."]}),"\n",(0,t.jsxs)(i.p,{children:[(0,t.jsx)(i.strong,{children:"Deliverable"}),": A comprehensive comparison table with explanations for each criterion."]}),"\n",(0,t.jsx)(i.h3,{id:"exercise-13-digital-twin-application-scenarios",children:"Exercise 1.3: Digital Twin Application Scenarios"}),"\n",(0,t.jsxs)(i.p,{children:[(0,t.jsx)(i.strong,{children:"Objective"}),": Identify practical applications of digital twin technology in humanoid robotics."]}),"\n",(0,t.jsxs)(i.p,{children:[(0,t.jsx)(i.strong,{children:"Task"}),": Research and describe 3 specific scenarios where digital twin technology would be beneficial for humanoid robot development, testing, or operation. For each scenario, explain:"]}),"\n",(0,t.jsxs)(i.ol,{children:["\n",(0,t.jsx)(i.li,{children:"The specific challenge being addressed"}),"\n",(0,t.jsx)(i.li,{children:"How the digital twin would be implemented"}),"\n",(0,t.jsx)(i.li,{children:"The expected benefits"}),"\n",(0,t.jsx)(i.li,{children:"Potential limitations or challenges"}),"\n"]}),"\n",(0,t.jsxs)(i.p,{children:[(0,t.jsx)(i.strong,{children:"Deliverable"}),": A report with 3 detailed scenarios including diagrams if helpful."]}),"\n",(0,t.jsx)(i.h2,{id:"chapter-2-exercises-gazebo-simulation-environment",children:"Chapter 2 Exercises: Gazebo Simulation Environment"}),"\n",(0,t.jsx)(i.h3,{id:"exercise-21-gazebo-environment-setup",children:"Exercise 2.1: Gazebo Environment Setup"}),"\n",(0,t.jsxs)(i.p,{children:[(0,t.jsx)(i.strong,{children:"Objective"}),": Install and configure Gazebo for humanoid robot simulation."]}),"\n",(0,t.jsxs)(i.p,{children:[(0,t.jsx)(i.strong,{children:"Task"}),": Install Gazebo Garden (or latest stable version) with ROS2 Humble integration on your system. Verify the installation by:"]}),"\n",(0,t.jsxs)(i.ol,{children:["\n",(0,t.jsx)(i.li,{children:"Launching Gazebo without errors"}),"\n",(0,t.jsx)(i.li,{children:"Running the empty world simulation"}),"\n",(0,t.jsx)(i.li,{children:"Testing basic interaction (moving objects, changing camera view)"}),"\n",(0,t.jsx)(i.li,{children:"Verifying ROS2 integration by publishing/subscribing to topics"}),"\n"]}),"\n",(0,t.jsxs)(i.p,{children:[(0,t.jsx)(i.strong,{children:"Deliverable"}),": Screenshot of Gazebo running with a simple world, plus a text file documenting your installation process and any issues encountered."]}),"\n",(0,t.jsx)(i.h3,{id:"exercise-22-custom-world-creation",children:"Exercise 2.2: Custom World Creation"}),"\n",(0,t.jsxs)(i.p,{children:[(0,t.jsx)(i.strong,{children:"Objective"}),": Create a custom environment for humanoid robot testing."]}),"\n",(0,t.jsxs)(i.p,{children:[(0,t.jsx)(i.strong,{children:"Task"}),": Design and implement a Gazebo world file that includes:"]}),"\n",(0,t.jsxs)(i.ol,{children:["\n",(0,t.jsx)(i.li,{children:"Ground plane with appropriate texture"}),"\n",(0,t.jsx)(i.li,{children:"At least 3 obstacles (different shapes and sizes)"}),"\n",(0,t.jsx)(i.li,{children:"A ramp or incline"}),"\n",(0,t.jsx)(i.li,{children:"Static objects for navigation testing"}),"\n",(0,t.jsx)(i.li,{children:"Appropriate lighting configuration"}),"\n"]}),"\n",(0,t.jsxs)(i.p,{children:[(0,t.jsx)(i.strong,{children:"Deliverable"}),": The SDF world file and a screenshot of the environment in Gazebo."]}),"\n",(0,t.jsx)(i.h3,{id:"exercise-23-robot-model-integration",children:"Exercise 2.3: Robot Model Integration"}),"\n",(0,t.jsxs)(i.p,{children:[(0,t.jsx)(i.strong,{children:"Objective"}),": Integrate a simple robot model into Gazebo with proper physics properties."]}),"\n",(0,t.jsxs)(i.p,{children:[(0,t.jsx)(i.strong,{children:"Task"}),": Create a simple humanoid robot URDF model with:"]}),"\n",(0,t.jsxs)(i.ol,{children:["\n",(0,t.jsx)(i.li,{children:"At least 6 links (base, torso, 2 arms, 2 legs)"}),"\n",(0,t.jsx)(i.li,{children:"Appropriate joints connecting the links"}),"\n",(0,t.jsx)(i.li,{children:"Physics properties (mass, inertia, collision geometry)"}),"\n",(0,t.jsx)(i.li,{children:"Visual properties (colors, shapes)"}),"\n",(0,t.jsx)(i.li,{children:"Gazebo-specific plugins for ROS2 integration"}),"\n"]}),"\n",(0,t.jsxs)(i.p,{children:[(0,t.jsx)(i.strong,{children:"Deliverable"}),": The URDF file and a screenshot of the robot loaded in Gazebo."]}),"\n",(0,t.jsx)(i.h2,{id:"chapter-3-exercises-unity-simulation-environment",children:"Chapter 3 Exercises: Unity Simulation Environment"}),"\n",(0,t.jsx)(i.h3,{id:"exercise-31-unity-robotics-setup",children:"Exercise 3.1: Unity Robotics Setup"}),"\n",(0,t.jsxs)(i.p,{children:[(0,t.jsx)(i.strong,{children:"Objective"}),": Set up Unity for robotics simulation with ROS2 integration."]}),"\n",(0,t.jsxs)(i.p,{children:[(0,t.jsx)(i.strong,{children:"Task"}),": Install Unity 2021.3 LTS or newer and configure the Unity Robotics packages:"]}),"\n",(0,t.jsxs)(i.ol,{children:["\n",(0,t.jsx)(i.li,{children:"Install Unity Robotics Hub"}),"\n",(0,t.jsx)(i.li,{children:"Install ROS TCP Connector"}),"\n",(0,t.jsx)(i.li,{children:"Install URDF Importer"}),"\n",(0,t.jsx)(i.li,{children:"Test basic ROS2 communication with a simple publisher/subscriber example"}),"\n"]}),"\n",(0,t.jsxs)(i.p,{children:[(0,t.jsx)(i.strong,{children:"Deliverable"}),": Screenshots showing the installed packages and successful ROS2 communication test."]}),"\n",(0,t.jsx)(i.h3,{id:"exercise-32-robot-model-import-and-configuration",children:"Exercise 3.2: Robot Model Import and Configuration"}),"\n",(0,t.jsxs)(i.p,{children:[(0,t.jsx)(i.strong,{children:"Objective"}),": Import and configure a robot model in Unity."]}),"\n",(0,t.jsxs)(i.p,{children:[(0,t.jsx)(i.strong,{children:"Task"}),": Import a humanoid robot model (either as URDF or as a Unity model) and:"]}),"\n",(0,t.jsxs)(i.ol,{children:["\n",(0,t.jsx)(i.li,{children:"Configure the joint hierarchy properly"}),"\n",(0,t.jsx)(i.li,{children:"Set up physics properties for each link"}),"\n",(0,t.jsx)(i.li,{children:"Configure colliders for physical interaction"}),"\n",(0,t.jsx)(i.li,{children:"Test basic movement and joint constraints"}),"\n"]}),"\n",(0,t.jsxs)(i.p,{children:[(0,t.jsx)(i.strong,{children:"Deliverable"}),": Screenshots showing the imported robot with joint hierarchy and a brief video or animated GIF showing the robot moving."]}),"\n",(0,t.jsx)(i.h3,{id:"exercise-33-environment-creation",children:"Exercise 3.3: Environment Creation"}),"\n",(0,t.jsxs)(i.p,{children:[(0,t.jsx)(i.strong,{children:"Objective"}),": Create a Unity scene for humanoid robot testing."]}),"\n",(0,t.jsxs)(i.p,{children:[(0,t.jsx)(i.strong,{children:"Task"}),": Create a Unity scene that includes:"]}),"\n",(0,t.jsxs)(i.ol,{children:["\n",(0,t.jsx)(i.li,{children:"A ground plane with appropriate physics properties"}),"\n",(0,t.jsx)(i.li,{children:"At least 3 obstacles for navigation testing"}),"\n",(0,t.jsx)(i.li,{children:"A ramp or incline for walking tests"}),"\n",(0,t.jsx)(i.li,{children:"Appropriate lighting setup"}),"\n",(0,t.jsx)(i.li,{children:"A simple navigation mesh for pathfinding"}),"\n"]}),"\n",(0,t.jsxs)(i.p,{children:[(0,t.jsx)(i.strong,{children:"Deliverable"}),": The Unity scene file and screenshots showing different views of the environment."]}),"\n",(0,t.jsx)(i.h2,{id:"chapter-4-exercises-robot-modeling-and-physics",children:"Chapter 4 Exercises: Robot Modeling and Physics"}),"\n",(0,t.jsx)(i.h3,{id:"exercise-41-urdf-model-development",children:"Exercise 4.1: URDF Model Development"}),"\n",(0,t.jsxs)(i.p,{children:[(0,t.jsx)(i.strong,{children:"Objective"}),": Create a detailed humanoid robot model with accurate physical properties."]}),"\n",(0,t.jsxs)(i.p,{children:[(0,t.jsx)(i.strong,{children:"Task"}),": Develop a complete URDF model for a humanoid robot with:"]}),"\n",(0,t.jsxs)(i.ol,{children:["\n",(0,t.jsx)(i.li,{children:"Proper kinematic chain (base to feet and hands)"}),"\n",(0,t.jsx)(i.li,{children:"Accurate mass and inertia properties for each link"}),"\n",(0,t.jsx)(i.li,{children:"Appropriate joint limits and dynamics"}),"\n",(0,t.jsx)(i.li,{children:"Proper visual and collision geometries"}),"\n",(0,t.jsx)(i.li,{children:"Gazebo-specific configurations for physics simulation"}),"\n"]}),"\n",(0,t.jsxs)(i.p,{children:[(0,t.jsx)(i.strong,{children:"Deliverable"}),": The complete URDF file and validation that it loads correctly in both RViz and Gazebo."]}),"\n",(0,t.jsx)(i.h3,{id:"exercise-42-physics-parameter-tuning",children:"Exercise 4.2: Physics Parameter Tuning"}),"\n",(0,t.jsxs)(i.p,{children:[(0,t.jsx)(i.strong,{children:"Objective"}),": Tune physics parameters for realistic robot behavior."]}),"\n",(0,t.jsxs)(i.p,{children:[(0,t.jsx)(i.strong,{children:"Task"}),": Implement and tune physics parameters for a humanoid robot:"]}),"\n",(0,t.jsxs)(i.ol,{children:["\n",(0,t.jsx)(i.li,{children:"Adjust mass distribution to match physical robot"}),"\n",(0,t.jsx)(i.li,{children:"Tune damping and friction parameters"}),"\n",(0,t.jsx)(i.li,{children:"Configure contact properties for stable simulation"}),"\n",(0,t.jsx)(i.li,{children:"Validate that the robot behaves realistically when standing and moving"}),"\n"]}),"\n",(0,t.jsxs)(i.p,{children:[(0,t.jsx)(i.strong,{children:"Deliverable"}),": Documentation of the tuning process and parameters used, with video showing stable robot behavior."]}),"\n",(0,t.jsx)(i.h3,{id:"exercise-43-unity-physics-configuration",children:"Exercise 4.3: Unity Physics Configuration"}),"\n",(0,t.jsxs)(i.p,{children:[(0,t.jsx)(i.strong,{children:"Objective"}),": Configure Unity physics to match the real robot's characteristics."]}),"\n",(0,t.jsxs)(i.p,{children:[(0,t.jsx)(i.strong,{children:"Task"}),": Configure Unity physics components for a humanoid robot model:"]}),"\n",(0,t.jsxs)(i.ol,{children:["\n",(0,t.jsx)(i.li,{children:"Set up rigidbodies with appropriate mass values"}),"\n",(0,t.jsx)(i.li,{children:"Configure joint constraints matching the URDF model"}),"\n",(0,t.jsx)(i.li,{children:"Tune damping and friction properties"}),"\n",(0,t.jsx)(i.li,{children:"Implement collision detection and response"}),"\n"]}),"\n",(0,t.jsxs)(i.p,{children:[(0,t.jsx)(i.strong,{children:"Deliverable"}),": Unity script files for physics configuration and a demonstration of the robot's physical behavior."]}),"\n",(0,t.jsx)(i.h2,{id:"chapter-5-exercises-sensor-simulation-and-integration",children:"Chapter 5 Exercises: Sensor Simulation and Integration"}),"\n",(0,t.jsx)(i.h3,{id:"exercise-51-camera-sensor-integration",children:"Exercise 5.1: Camera Sensor Integration"}),"\n",(0,t.jsxs)(i.p,{children:[(0,t.jsx)(i.strong,{children:"Objective"}),": Integrate and test camera sensor simulation in both environments."]}),"\n",(0,t.jsxs)(i.p,{children:[(0,t.jsx)(i.strong,{children:"Task"}),": Implement camera sensors in both Gazebo and Unity:"]}),"\n",(0,t.jsxs)(i.ol,{children:["\n",(0,t.jsx)(i.li,{children:"Configure camera parameters to match a real camera"}),"\n",(0,t.jsx)(i.li,{children:"Implement ROS2 message publishing for both environments"}),"\n",(0,t.jsx)(i.li,{children:"Test image quality and field of view"}),"\n",(0,t.jsx)(i.li,{children:"Add appropriate noise models to simulate real sensor characteristics"}),"\n"]}),"\n",(0,t.jsxs)(i.p,{children:[(0,t.jsx)(i.strong,{children:"Deliverable"}),": Configuration files for both environments and sample images from both simulations."]}),"\n",(0,t.jsx)(i.h3,{id:"exercise-52-lidar-sensor-implementation",children:"Exercise 5.2: LIDAR Sensor Implementation"}),"\n",(0,t.jsxs)(i.p,{children:[(0,t.jsx)(i.strong,{children:"Objective"}),": Implement LIDAR sensor simulation with realistic characteristics."]}),"\n",(0,t.jsxs)(i.p,{children:[(0,t.jsx)(i.strong,{children:"Task"}),": Create LIDAR sensor implementations in both Gazebo and Unity:"]}),"\n",(0,t.jsxs)(i.ol,{children:["\n",(0,t.jsx)(i.li,{children:"Configure LIDAR parameters (range, resolution, field of view)"}),"\n",(0,t.jsx)(i.li,{children:"Implement point cloud generation in Unity"}),"\n",(0,t.jsx)(i.li,{children:"Test obstacle detection capabilities"}),"\n",(0,t.jsx)(i.li,{children:"Compare performance between environments"}),"\n"]}),"\n",(0,t.jsxs)(i.p,{children:[(0,t.jsx)(i.strong,{children:"Deliverable"}),": Configuration files and sample point cloud data from both environments."]}),"\n",(0,t.jsx)(i.h3,{id:"exercise-53-multi-sensor-fusion",children:"Exercise 5.3: Multi-Sensor Fusion"}),"\n",(0,t.jsxs)(i.p,{children:[(0,t.jsx)(i.strong,{children:"Objective"}),": Implement basic sensor fusion between multiple simulated sensors."]}),"\n",(0,t.jsxs)(i.p,{children:[(0,t.jsx)(i.strong,{children:"Task"}),": Create a system that combines data from multiple simulated sensors:"]}),"\n",(0,t.jsxs)(i.ol,{children:["\n",(0,t.jsx)(i.li,{children:"Integrate IMU, camera, and LIDAR data"}),"\n",(0,t.jsx)(i.li,{children:"Implement basic fusion algorithm (e.g., for pose estimation)"}),"\n",(0,t.jsx)(i.li,{children:"Test the fused output in a simple scenario"}),"\n",(0,t.jsx)(i.li,{children:"Compare results with individual sensor outputs"}),"\n"]}),"\n",(0,t.jsxs)(i.p,{children:[(0,t.jsx)(i.strong,{children:"Deliverable"}),": Fusion algorithm implementation and comparison analysis of results."]}),"\n",(0,t.jsx)(i.h2,{id:"chapter-6-exercises-virtual-testing-and-validation",children:"Chapter 6 Exercises: Virtual Testing and Validation"}),"\n",(0,t.jsx)(i.h3,{id:"exercise-61-test-scenario-development",children:"Exercise 6.1: Test Scenario Development"}),"\n",(0,t.jsxs)(i.p,{children:[(0,t.jsx)(i.strong,{children:"Objective"}),": Develop comprehensive test scenarios for humanoid robot validation."]}),"\n",(0,t.jsxs)(i.p,{children:[(0,t.jsx)(i.strong,{children:"Task"}),": Create 3 different test scenarios for a humanoid robot:"]}),"\n",(0,t.jsxs)(i.ol,{children:["\n",(0,t.jsx)(i.li,{children:"Standing balance test with stability metrics"}),"\n",(0,t.jsx)(i.li,{children:"Navigation test with obstacle avoidance"}),"\n",(0,t.jsx)(i.li,{children:"Simple manipulation task (e.g., reaching or grasping)"}),"\n"]}),"\n",(0,t.jsx)(i.p,{children:"For each scenario, implement:"}),"\n",(0,t.jsxs)(i.ul,{children:["\n",(0,t.jsx)(i.li,{children:"Setup procedures"}),"\n",(0,t.jsx)(i.li,{children:"Execution protocols"}),"\n",(0,t.jsx)(i.li,{children:"Success/failure criteria"}),"\n",(0,t.jsx)(i.li,{children:"Performance metrics"}),"\n"]}),"\n",(0,t.jsxs)(i.p,{children:[(0,t.jsx)(i.strong,{children:"Deliverable"}),": Detailed test scenario descriptions with implementation code and results."]}),"\n",(0,t.jsx)(i.h3,{id:"exercise-62-automated-testing-framework",children:"Exercise 6.2: Automated Testing Framework"}),"\n",(0,t.jsxs)(i.p,{children:[(0,t.jsx)(i.strong,{children:"Objective"}),": Implement an automated testing framework for robot validation."]}),"\n",(0,t.jsxs)(i.p,{children:[(0,t.jsx)(i.strong,{children:"Task"}),": Create an automated testing framework that:"]}),"\n",(0,t.jsxs)(i.ol,{children:["\n",(0,t.jsx)(i.li,{children:"Executes multiple test scenarios automatically"}),"\n",(0,t.jsx)(i.li,{children:"Collects performance metrics"}),"\n",(0,t.jsx)(i.li,{children:"Generates test reports"}),"\n",(0,t.jsx)(i.li,{children:"Handles test failures gracefully"}),"\n",(0,t.jsx)(i.li,{children:"Provides statistical analysis of results"}),"\n"]}),"\n",(0,t.jsxs)(i.p,{children:[(0,t.jsx)(i.strong,{children:"Deliverable"}),": The testing framework code and sample test reports with results."]}),"\n",(0,t.jsx)(i.h3,{id:"exercise-63-performance-evaluation",children:"Exercise 6.3: Performance Evaluation"}),"\n",(0,t.jsxs)(i.p,{children:[(0,t.jsx)(i.strong,{children:"Objective"}),": Evaluate robot performance using quantitative metrics."]}),"\n",(0,t.jsxs)(i.p,{children:[(0,t.jsx)(i.strong,{children:"Task"}),": Implement performance evaluation for the humanoid robot including:"]}),"\n",(0,t.jsxs)(i.ol,{children:["\n",(0,t.jsx)(i.li,{children:"Mobility metrics (walking speed, stability, energy efficiency)"}),"\n",(0,t.jsx)(i.li,{children:"Navigation metrics (path efficiency, obstacle avoidance success)"}),"\n",(0,t.jsx)(i.li,{children:"Balance metrics (CoM stability, fall recovery time)"}),"\n",(0,t.jsx)(i.li,{children:"Task execution metrics (completion rate, execution time)"}),"\n"]}),"\n",(0,t.jsxs)(i.p,{children:[(0,t.jsx)(i.strong,{children:"Deliverable"}),": Evaluation framework implementation and performance reports with visualizations."]}),"\n",(0,t.jsx)(i.h2,{id:"chapter-7-exercises-integration-with-ros2",children:"Chapter 7 Exercises: Integration with ROS2"}),"\n",(0,t.jsx)(i.h3,{id:"exercise-71-ros2-gazebo-integration",children:"Exercise 7.1: ROS2-Gazebo Integration"}),"\n",(0,t.jsxs)(i.p,{children:[(0,t.jsx)(i.strong,{children:"Objective"}),": Implement complete ROS2-Gazebo integration for a humanoid robot."]}),"\n",(0,t.jsxs)(i.p,{children:[(0,t.jsx)(i.strong,{children:"Task"}),": Create a complete integration system with:"]}),"\n",(0,t.jsxs)(i.ol,{children:["\n",(0,t.jsx)(i.li,{children:"Robot model properly configured for ROS2"}),"\n",(0,t.jsx)(i.li,{children:"All necessary Gazebo plugins for ROS2 communication"}),"\n",(0,t.jsx)(i.li,{children:"Joint state publishing and command receiving"}),"\n",(0,t.jsx)(i.li,{children:"Sensor data publishing to ROS2 topics"}),"\n",(0,t.jsx)(i.li,{children:"Control command execution from ROS2"}),"\n"]}),"\n",(0,t.jsxs)(i.p,{children:[(0,t.jsx)(i.strong,{children:"Deliverable"}),": Complete URDF and launch files with demonstration of all integrated components."]}),"\n",(0,t.jsx)(i.h3,{id:"exercise-72-ros2-unity-integration",children:"Exercise 7.2: ROS2-Unity Integration"}),"\n",(0,t.jsxs)(i.p,{children:[(0,t.jsx)(i.strong,{children:"Objective"}),": Implement ROS2-Unity communication for robot control."]}),"\n",(0,t.jsxs)(i.p,{children:[(0,t.jsx)(i.strong,{children:"Task"}),": Create ROS2-Unity bridge with:"]}),"\n",(0,t.jsxs)(i.ol,{children:["\n",(0,t.jsx)(i.li,{children:"Proper ROS TCP Connector setup"}),"\n",(0,t.jsx)(i.li,{children:"Joint state publishing from Unity"}),"\n",(0,t.jsx)(i.li,{children:"Control command receiving from ROS2"}),"\n",(0,t.jsx)(i.li,{children:"Sensor data publishing from Unity to ROS2"}),"\n",(0,t.jsx)(i.li,{children:"Bidirectional communication testing"}),"\n"]}),"\n",(0,t.jsxs)(i.p,{children:[(0,t.jsx)(i.strong,{children:"Deliverable"}),": Unity scripts and ROS2 nodes with demonstration of communication."]}),"\n",(0,t.jsx)(i.h3,{id:"exercise-73-cross-environment-integration",children:"Exercise 7.3: Cross-Environment Integration"}),"\n",(0,t.jsxs)(i.p,{children:[(0,t.jsx)(i.strong,{children:"Objective"}),": Integrate both simulation environments with ROS2 for comparison."]}),"\n",(0,t.jsxs)(i.p,{children:[(0,t.jsx)(i.strong,{children:"Task"}),": Create a system that can work with both Gazebo and Unity through ROS2:"]}),"\n",(0,t.jsxs)(i.ol,{children:["\n",(0,t.jsx)(i.li,{children:"Same ROS2 interface for both environments"}),"\n",(0,t.jsx)(i.li,{children:"Ability to switch between environments"}),"\n",(0,t.jsx)(i.li,{children:"Consistent message formats and topics"}),"\n",(0,t.jsx)(i.li,{children:"Comparison of results between environments"}),"\n"]}),"\n",(0,t.jsxs)(i.p,{children:[(0,t.jsx)(i.strong,{children:"Deliverable"}),": Unified ROS2 interface and comparison analysis of both environments."]}),"\n",(0,t.jsx)(i.h2,{id:"comprehensive-assignment-complete-digital-twin-system",children:"Comprehensive Assignment: Complete Digital Twin System"}),"\n",(0,t.jsx)(i.h3,{id:"assignment-overview",children:"Assignment Overview"}),"\n",(0,t.jsx)(i.p,{children:"Develop a complete digital twin system for a humanoid robot that includes all components covered in the previous chapters."}),"\n",(0,t.jsx)(i.h3,{id:"requirements",children:"Requirements"}),"\n",(0,t.jsx)(i.p,{children:"Your system must include:"}),"\n",(0,t.jsxs)(i.ol,{children:["\n",(0,t.jsxs)(i.li,{children:[(0,t.jsx)(i.strong,{children:"Robot Model"}),": A detailed humanoid robot model with proper kinematics and dynamics"]}),"\n",(0,t.jsxs)(i.li,{children:[(0,t.jsx)(i.strong,{children:"Simulation Environments"}),": Both Gazebo and Unity implementations"]}),"\n",(0,t.jsxs)(i.li,{children:[(0,t.jsx)(i.strong,{children:"Sensor Integration"}),": Camera, LIDAR, IMU, and force/torque sensors"]}),"\n",(0,t.jsxs)(i.li,{children:[(0,t.jsx)(i.strong,{children:"ROS2 Integration"}),": Complete ROS2 communication for both environments"]}),"\n",(0,t.jsxs)(i.li,{children:[(0,t.jsx)(i.strong,{children:"Testing Framework"}),": Automated testing and validation system"]}),"\n",(0,t.jsxs)(i.li,{children:[(0,t.jsx)(i.strong,{children:"Performance Evaluation"}),": Comprehensive metrics and evaluation tools"]}),"\n"]}),"\n",(0,t.jsx)(i.h3,{id:"implementation-tasks",children:"Implementation Tasks"}),"\n",(0,t.jsxs)(i.ol,{children:["\n",(0,t.jsx)(i.li,{children:"Create a humanoid robot model suitable for both simulation environments"}),"\n",(0,t.jsx)(i.li,{children:"Implement the robot in both Gazebo and Unity"}),"\n",(0,t.jsx)(i.li,{children:"Integrate all required sensors in both environments"}),"\n",(0,t.jsx)(i.li,{children:"Set up ROS2 communication for both environments"}),"\n",(0,t.jsx)(i.li,{children:"Develop a testing framework that works with both environments"}),"\n",(0,t.jsx)(i.li,{children:"Implement performance evaluation tools"}),"\n",(0,t.jsx)(i.li,{children:"Create a simple control system to demonstrate functionality"}),"\n"]}),"\n",(0,t.jsx)(i.h3,{id:"deliverables",children:"Deliverables"}),"\n",(0,t.jsxs)(i.ol,{children:["\n",(0,t.jsx)(i.li,{children:"Complete source code for both simulation environments"}),"\n",(0,t.jsx)(i.li,{children:"ROS2 configuration and launch files"}),"\n",(0,t.jsx)(i.li,{children:"Test scenarios and validation results"}),"\n",(0,t.jsx)(i.li,{children:"Performance evaluation reports"}),"\n",(0,t.jsx)(i.li,{children:"Documentation of the complete system"}),"\n",(0,t.jsx)(i.li,{children:"Comparison analysis between Gazebo and Unity implementations"}),"\n"]}),"\n",(0,t.jsx)(i.h3,{id:"evaluation-criteria",children:"Evaluation Criteria"}),"\n",(0,t.jsxs)(i.ul,{children:["\n",(0,t.jsx)(i.li,{children:"Completeness of implementation (all required components)"}),"\n",(0,t.jsx)(i.li,{children:"Quality of simulation (realistic behavior)"}),"\n",(0,t.jsx)(i.li,{children:"Integration quality (smooth ROS2 communication)"}),"\n",(0,t.jsx)(i.li,{children:"Testing and validation (comprehensive test coverage)"}),"\n",(0,t.jsx)(i.li,{children:"Performance (efficient operation)"}),"\n",(0,t.jsx)(i.li,{children:"Documentation (clear and comprehensive)"}),"\n"]}),"\n",(0,t.jsx)(i.h2,{id:"solutions-and-assessment-rubric",children:"Solutions and Assessment Rubric"}),"\n",(0,t.jsx)(i.h3,{id:"chapter-1-solutions",children:"Chapter 1 Solutions"}),"\n",(0,t.jsxs)(i.ul,{children:["\n",(0,t.jsxs)(i.li,{children:[(0,t.jsx)(i.strong,{children:"Exercise 1.1"}),": Look for clear identification of digital twin components with proper data flow"]}),"\n",(0,t.jsxs)(i.li,{children:[(0,t.jsx)(i.strong,{children:"Exercise 1.2"}),": Expect comprehensive comparison highlighting key differences"]}),"\n",(0,t.jsxs)(i.li,{children:[(0,t.jsx)(i.strong,{children:"Exercise 1.3"}),": Solutions should show practical understanding of digital twin applications"]}),"\n"]}),"\n",(0,t.jsx)(i.h3,{id:"chapter-2-solutions",children:"Chapter 2 Solutions"}),"\n",(0,t.jsxs)(i.ul,{children:["\n",(0,t.jsxs)(i.li,{children:[(0,t.jsx)(i.strong,{children:"Exercise 2.1"}),": Installation should be successful with proper verification"]}),"\n",(0,t.jsxs)(i.li,{children:[(0,t.jsx)(i.strong,{children:"Exercise 2.2"}),": World should be functional with appropriate elements"]}),"\n",(0,t.jsxs)(i.li,{children:[(0,t.jsx)(i.strong,{children:"Exercise 2.3"}),": Robot model should be properly configured with physics"]}),"\n"]}),"\n",(0,t.jsx)(i.h3,{id:"chapter-3-solutions",children:"Chapter 3 Solutions"}),"\n",(0,t.jsxs)(i.ul,{children:["\n",(0,t.jsxs)(i.li,{children:[(0,t.jsx)(i.strong,{children:"Exercise 3.1"}),": Unity setup should include all required packages and basic communication"]}),"\n",(0,t.jsxs)(i.li,{children:[(0,t.jsx)(i.strong,{children:"Exercise 3.2"}),": Robot import should maintain proper structure and functionality"]}),"\n",(0,t.jsxs)(i.li,{children:[(0,t.jsx)(i.strong,{children:"Exercise 3.3"}),": Environment should be suitable for robot testing"]}),"\n"]}),"\n",(0,t.jsx)(i.h3,{id:"assessment-rubric",children:"Assessment Rubric"}),"\n",(0,t.jsxs)(i.table,{children:[(0,t.jsx)(i.thead,{children:(0,t.jsxs)(i.tr,{children:[(0,t.jsx)(i.th,{children:"Criteria"}),(0,t.jsx)(i.th,{children:"Excellent (4)"}),(0,t.jsx)(i.th,{children:"Good (3)"}),(0,t.jsx)(i.th,{children:"Satisfactory (2)"}),(0,t.jsx)(i.th,{children:"Needs Improvement (1)"})]})}),(0,t.jsxs)(i.tbody,{children:[(0,t.jsxs)(i.tr,{children:[(0,t.jsx)(i.td,{children:"Technical Implementation"}),(0,t.jsx)(i.td,{children:"Complete and robust implementation"}),(0,t.jsx)(i.td,{children:"Mostly complete with minor issues"}),(0,t.jsx)(i.td,{children:"Partially complete with some issues"}),(0,t.jsx)(i.td,{children:"Incomplete or major issues"})]}),(0,t.jsxs)(i.tr,{children:[(0,t.jsx)(i.td,{children:"Code Quality"}),(0,t.jsx)(i.td,{children:"Clean, well-documented, efficient"}),(0,t.jsx)(i.td,{children:"Good organization and comments"}),(0,t.jsx)(i.td,{children:"Adequate documentation"}),(0,t.jsx)(i.td,{children:"Poor structure or documentation"})]}),(0,t.jsxs)(i.tr,{children:[(0,t.jsx)(i.td,{children:"Functionality"}),(0,t.jsx)(i.td,{children:"All features work as expected"}),(0,t.jsx)(i.td,{children:"Most features work"}),(0,t.jsx)(i.td,{children:"Some features work"}),(0,t.jsx)(i.td,{children:"Many features non-functional"})]}),(0,t.jsxs)(i.tr,{children:[(0,t.jsx)(i.td,{children:"Understanding"}),(0,t.jsx)(i.td,{children:"Deep understanding of concepts"}),(0,t.jsx)(i.td,{children:"Good understanding"}),(0,t.jsx)(i.td,{children:"Basic understanding"}),(0,t.jsx)(i.td,{children:"Limited understanding"})]}),(0,t.jsxs)(i.tr,{children:[(0,t.jsx)(i.td,{children:"Problem Solving"}),(0,t.jsx)(i.td,{children:"Creative solutions, optimization"}),(0,t.jsx)(i.td,{children:"Effective solutions"}),(0,t.jsx)(i.td,{children:"Adequate solutions"}),(0,t.jsx)(i.td,{children:"Struggles with basic problems"})]}),(0,t.jsxs)(i.tr,{children:[(0,t.jsx)(i.td,{children:"Documentation"}),(0,t.jsx)(i.td,{children:"Comprehensive, clear, helpful"}),(0,t.jsx)(i.td,{children:"Good documentation"}),(0,t.jsx)(i.td,{children:"Basic documentation"}),(0,t.jsx)(i.td,{children:"Poor or missing documentation"})]})]})]}),"\n",(0,t.jsx)(i.p,{children:"This rubric can be applied to each exercise and the comprehensive assignment to provide consistent evaluation across all submissions."})]})}function h(e={}){const{wrapper:i}={...(0,r.R)(),...e.components};return i?(0,t.jsx)(i,{...e,children:(0,t.jsx)(d,{...e})}):d(e)}}}]);