"use strict";(globalThis.webpackChunkphysical_ai_textbook=globalThis.webpackChunkphysical_ai_textbook||[]).push([[8184],{4984(n,e,t){t.r(e),t.d(e,{assets:()=>l,contentTitle:()=>i,default:()=>p,frontMatter:()=>o,metadata:()=>r,toc:()=>c});const r=JSON.parse('{"id":"module-4-action-planning","title":"Chapter 4 - Action Planning and Execution","description":"Action Planning Systems for Humanoid Robots","source":"@site/docs/module-4-action-planning.md","sourceDirName":".","slug":"/module-4-action-planning","permalink":"/ur/docs/module-4-action-planning","draft":false,"unlisted":false,"editUrl":"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/module-4-action-planning.md","tags":[],"version":"current","frontMatter":{"id":"module-4-action-planning","title":"Chapter 4 - Action Planning and Execution","sidebar_label":"Chapter 4 - Action Planning and Execution"},"sidebar":"tutorialSidebar","previous":{"title":"Chapter 3 - Language Understanding for Robotics","permalink":"/ur/docs/module-4-language-understanding"},"next":{"title":"Chapter 5 - VLA Integration Architectures","permalink":"/ur/docs/module-4-vla-integration"}}');var a=t(4848),s=t(8453);const o={id:"module-4-action-planning",title:"Chapter 4 - Action Planning and Execution",sidebar_label:"Chapter 4 - Action Planning and Execution"},i="Chapter 4: Action Planning and Execution",l={},c=[{value:"Action Planning Systems for Humanoid Robots",id:"action-planning-systems-for-humanoid-robots",level:2},{value:"Action Planning Fundamentals",id:"action-planning-fundamentals",level:3}];function u(n){const e={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,s.R)(),...n.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(e.header,{children:(0,a.jsx)(e.h1,{id:"chapter-4-action-planning-and-execution",children:"Chapter 4: Action Planning and Execution"})}),"\n",(0,a.jsx)(e.h2,{id:"action-planning-systems-for-humanoid-robots",children:"Action Planning Systems for Humanoid Robots"}),"\n",(0,a.jsx)(e.p,{children:"Action planning in humanoid robots is a complex process that involves coordinating multiple degrees of freedom while considering environmental constraints, balance requirements, and task objectives. The planning system must generate feasible trajectories for the robot's many joints while maintaining stability and achieving the desired goal."}),"\n",(0,a.jsx)(e.h3,{id:"action-planning-fundamentals",children:"Action Planning Fundamentals"}),"\n",(0,a.jsx)(e.p,{children:"Action planning for humanoid robots involves several critical components:"}),"\n",(0,a.jsxs)(e.ul,{children:["\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Task Decomposition"}),": Breaking complex tasks into manageable subtasks"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Trajectory Generation"}),": Creating smooth, feasible trajectories for each joint"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Constraint Satisfaction"}),": Ensuring all kinematic, dynamic, and environmental constraints are met"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Balance Control"}),": Maintaining stability throughout the action sequence"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Collision Avoidance"}),": Ensuring the robot doesn't collide with obstacles or itself"]}),"\n"]}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-python",children:"import numpy as np\r\nimport matplotlib.pyplot as plt\r\nfrom scipy.interpolate import interp1d\r\nfrom scipy.optimize import minimize\r\nimport time\r\n\r\nclass HumanoidActionPlanner:\r\n    \"\"\"\r\n    Action planning system for humanoid robots\r\n    \"\"\"\r\n    def __init__(self, robot_model):\r\n        self.robot_model = robot_model\r\n        self.task_decomposer = TaskDecomposer()\r\n        self.trajectory_generator = TrajectoryGenerator()\r\n        self.constraint_checker = ConstraintChecker()\r\n        self.balance_controller = BalanceController()\r\n\r\n    def plan_action_sequence(self, high_level_task, environment):\r\n        \"\"\"\r\n        Plan a sequence of actions to accomplish a high-level task\r\n        \"\"\"\r\n        # Decompose high-level task into subtasks\r\n        subtasks = self.task_decomposer.decompose(high_level_task)\r\n\r\n        # Plan each subtask\r\n        action_sequence = []\r\n        current_state = self.robot_model.get_current_state()\r\n\r\n        for subtask in subtasks:\r\n            # Generate action plan for subtask\r\n            action_plan = self._plan_single_action(subtask, current_state, environment)\r\n\r\n            if action_plan is not None:\r\n                action_sequence.append(action_plan)\r\n                # Update current state after action\r\n                current_state = self._predict_state_after_action(\r\n                    current_state, action_plan\r\n                )\r\n            else:\r\n                # Planning failed, return None\r\n                return None\r\n\r\n        return action_sequence\r\n\r\n    def _plan_single_action(self, subtask, current_state, environment):\r\n        \"\"\"\r\n        Plan a single action for a subtask\r\n        \"\"\"\r\n        # Determine required end-state\r\n        target_state = self._determine_target_state(subtask, current_state, environment)\r\n\r\n        # Check feasibility\r\n        if not self._is_action_feasible(current_state, target_state, environment):\r\n            return None\r\n\r\n        # Generate trajectory\r\n        trajectory = self.trajectory_generator.generate(\r\n            current_state, target_state, environment\r\n        )\r\n\r\n        # Verify trajectory satisfies constraints\r\n        if self.constraint_checker.verify(trajectory, environment):\r\n            return {\r\n                'subtask': subtask,\r\n                'trajectory': trajectory,\r\n                'start_state': current_state,\r\n                'end_state': target_state,\r\n                'duration': self._calculate_duration(trajectory)\r\n            }\r\n        else:\r\n            return None\r\n\r\n    def _determine_target_state(self, subtask, current_state, environment):\r\n        \"\"\"\r\n        Determine the target state for a subtask\r\n        \"\"\"\r\n        if subtask.type == 'navigate':\r\n            # Navigation task: move to a location\r\n            return {\r\n                'position': subtask.parameters['target_position'],\r\n                'orientation': subtask.parameters.get('target_orientation', current_state['orientation']),\r\n                'joints': self._calculate_reach_pose(\r\n                    subtask.parameters['target_position'],\r\n                    current_state\r\n                )\r\n            }\r\n        elif subtask.type == 'grasp':\r\n            # Grasping task: manipulate an object\r\n            return {\r\n                'position': subtask.parameters['object_position'],\r\n                'joints': self._calculate_grasp_joints(\r\n                    subtask.parameters['object_position'],\r\n                    subtask.parameters['object_orientation']\r\n                ),\r\n                'gripper': 'closed'\r\n            }\r\n        elif subtask.type == 'manipulate':\r\n            # Manipulation task: move object to new location\r\n            return {\r\n                'position': subtask.parameters['destination'],\r\n                'joints': self._calculate_manipulation_pose(\r\n                    subtask.parameters['destination']\r\n                ),\r\n                'gripper': 'closed'  # Assuming object is already grasped\r\n            }\r\n        else:\r\n            # Default: return current state\r\n            return current_state\r\n\r\n    def _is_action_feasible(self, current_state, target_state, environment):\r\n        \"\"\"\r\n        Check if action is feasible\r\n        \"\"\"\r\n        # Check reachability\r\n        if not self._is_reachable(current_state, target_state, environment):\r\n            return False\r\n\r\n        # Check balance constraints\r\n        if not self.balance_controller.is_balance_maintainable(\r\n            current_state, target_state\r\n        ):\r\n            return False\r\n\r\n        # Check collision constraints\r\n        if not self._is_collision_free(current_state, target_state, environment):\r\n            return False\r\n\r\n        return True\r\n\r\n    def _is_reachable(self, current_state, target_state, environment):\r\n        \"\"\"\r\n        Check if target state is reachable from current state\r\n        \"\"\"\r\n        # Calculate required joint angles for target position\r\n        target_joints = target_state.get('joints', current_state['joints'])\r\n\r\n        # Check if joint angles are within limits\r\n        for joint_idx, angle in enumerate(target_joints):\r\n            if (angle < self.robot_model.joint_limits[joint_idx][0] or\r\n                angle > self.robot_model.joint_limits[joint_idx][1]):\r\n                return False\r\n\r\n        return True\r\n\r\n    def _is_collision_free(self, current_state, target_state, environment):\r\n        \"\"\"\r\n        Check if motion is collision-free\r\n        \"\"\"\r\n        # Interpolate between states to check for collisions\r\n        trajectory = self.trajectory_generator.interpolate_trajectory(\r\n            current_state, target_state, num_points=50\r\n        )\r\n\r\n        for state in trajectory:\r\n            if self.constraint_checker.has_collision(state, environment):\r\n                return False\r\n\r\n        return True\r\n\r\n    def _predict_state_after_action(self, current_state, action_plan):\r\n        \"\"\"\r\n        Predict robot state after executing action plan\r\n        \"\"\"\r\n        # For simplicity, assume final state of trajectory is final state\r\n        final_state = action_plan['trajectory'][-1]\r\n        return final_state\r\n\r\n    def _calculate_duration(self, trajectory):\r\n        \"\"\"\r\n        Calculate duration of trajectory\r\n        \"\"\"\r\n        return len(trajectory) * self.robot_model.control_timestep\r\n\r\nclass TaskDecomposer:\r\n    \"\"\"\r\n    Decompose high-level tasks into executable subtasks\r\n    \"\"\"\r\n    def __init__(self):\r\n        self.task_templates = self._load_task_templates()\r\n\r\n    def _load_task_templates(self):\r\n        \"\"\"\r\n        Load templates for common tasks\r\n        \"\"\"\r\n        return {\r\n            'fetch_object': [\r\n                {'type': 'navigate', 'parameters': {}},\r\n                {'type': 'locate_object', 'parameters': {}},\r\n                {'type': 'approach_object', 'parameters': {}},\r\n                {'type': 'grasp_object', 'parameters': {}},\r\n                {'type': 'lift_object', 'parameters': {}},\r\n                {'type': 'navigate', 'parameters': {}},\r\n                {'type': 'place_object', 'parameters': {}}\r\n            ],\r\n            'open_door': [\r\n                {'type': 'navigate', 'parameters': {}},\r\n                {'type': 'align_with_door', 'parameters': {}},\r\n                {'type': 'reach_handle', 'parameters': {}},\r\n                {'type': 'grasp_handle', 'parameters': {}},\r\n                {'type': 'turn_handle', 'parameters': {}},\r\n                {'type': 'push_door', 'parameters': {}}\r\n            ],\r\n            'walk_to_location': [\r\n                {'type': 'navigate', 'parameters': {}}\r\n            ]\r\n        }\r\n\r\n    def decompose(self, high_level_task):\r\n        \"\"\"\r\n        Decompose high-level task into subtasks\r\n        \"\"\"\r\n        if high_level_task.name in self.task_templates:\r\n            # Clone template to avoid modifying\r\n            subtasks = []\r\n            for template_subtask in self.task_templates[high_level_task.name]:\r\n                subtask = template_subtask.copy()\r\n                subtask.update(high_level_task.parameters)  # Merge specific parameters\r\n                subtasks.append(type('Subtask', (), subtask)())\r\n            return subtasks\r\n        else:\r\n            # Unknown task type - return as single subtask\r\n            return [type('Subtask', (), {'type': 'generic', 'parameters': high_level_task.parameters})()]\n"})})]})}function p(n={}){const{wrapper:e}={...(0,s.R)(),...n.components};return e?(0,a.jsx)(e,{...n,children:(0,a.jsx)(u,{...n})}):u(n)}},8453(n,e,t){t.d(e,{R:()=>o,x:()=>i});var r=t(6540);const a={},s=r.createContext(a);function o(n){const e=r.useContext(s);return r.useMemo(function(){return"function"==typeof n?n(e):{...e,...n}},[e,n])}function i(n){let e;return e=n.disableParentContext?"function"==typeof n.components?n.components(a):n.components||a:o(n.components),r.createElement(s.Provider,{value:e},n.children)}}}]);