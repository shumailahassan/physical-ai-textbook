"use strict";(globalThis.webpackChunkphysical_ai_textbook=globalThis.webpackChunkphysical_ai_textbook||[]).push([[8954],{8261(n,i,r){r.r(i),r.d(i,{assets:()=>a,contentTitle:()=>s,default:()=>m,frontMatter:()=>l,metadata:()=>e,toc:()=>c});const e=JSON.parse('{"id":"module-2-robot-modeling-physics","title":"Chapter 4 - Robot Modeling and Physics","description":"Robot Modeling in Gazebo","source":"@site/docs/module-2-robot-modeling-physics.md","sourceDirName":".","slug":"/module-2-robot-modeling-physics","permalink":"/docs/module-2-robot-modeling-physics","draft":false,"unlisted":false,"editUrl":"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/module-2-robot-modeling-physics.md","tags":[],"version":"current","frontMatter":{"id":"module-2-robot-modeling-physics","title":"Chapter 4 - Robot Modeling and Physics","sidebar_label":"Chapter 4 - Robot Modeling and Physics"},"sidebar":"tutorialSidebar","previous":{"title":"Chapter 3 - Unity Simulation Environment","permalink":"/docs/module-2-unity-simulation"},"next":{"title":"Chapter 5 - Sensor Simulation and Integration","permalink":"/docs/module-2-sensor-simulation"}}');var o=r(4848),t=r(8453);const l={id:"module-2-robot-modeling-physics",title:"Chapter 4 - Robot Modeling and Physics",sidebar_label:"Chapter 4 - Robot Modeling and Physics"},s="Chapter 4: Robot Modeling and Physics",a={},c=[{value:"Robot Modeling in Gazebo",id:"robot-modeling-in-gazebo",level:2},{value:"URDF Format for Robot Description",id:"urdf-format-for-robot-description",level:3},{value:"Link and Joint Definitions",id:"link-and-joint-definitions",level:3},{value:"Collision and Visual Geometries",id:"collision-and-visual-geometries",level:3},{value:"Robot Modeling in Unity",id:"robot-modeling-in-unity",level:2},{value:"Importing URDF Models to Unity",id:"importing-urdf-models-to-unity",level:3},{value:"Manual Robot Creation in Unity",id:"manual-robot-creation-in-unity",level:3},{value:"Physics Configuration and Tuning",id:"physics-configuration-and-tuning",level:2},{value:"Physics Parameters for Realistic Simulation",id:"physics-parameters-for-realistic-simulation",level:3},{value:"Damping and Friction Configuration",id:"damping-and-friction-configuration",level:3},{value:"Collision Geometry and Visual Meshes",id:"collision-geometry-and-visual-meshes",level:2},{value:"Optimization Techniques",id:"optimization-techniques",level:3},{value:"Performance Considerations",id:"performance-considerations",level:3},{value:"Conclusion",id:"conclusion",level:2}];function d(n){const i={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,t.R)(),...n.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(i.header,{children:(0,o.jsx)(i.h1,{id:"chapter-4-robot-modeling-and-physics",children:"Chapter 4: Robot Modeling and Physics"})}),"\n",(0,o.jsx)(i.h2,{id:"robot-modeling-in-gazebo",children:"Robot Modeling in Gazebo"}),"\n",(0,o.jsx)(i.p,{children:"Creating accurate robot models for Gazebo simulation requires careful attention to both visual representation and physical properties. The Unified Robot Description Format (URDF) serves as the standard for defining robot models in ROS-based systems, which are then used by Gazebo for physics simulation."}),"\n",(0,o.jsx)(i.h3,{id:"urdf-format-for-robot-description",children:"URDF Format for Robot Description"}),"\n",(0,o.jsx)(i.p,{children:"URDF (Unified Robot Description Format) is an XML-based format that describes robot models. A complete humanoid robot model in URDF includes links (rigid bodies) and joints (constraints between links)."}),"\n",(0,o.jsx)(i.p,{children:"Here's a detailed example of a humanoid robot's URDF structure:"}),"\n",(0,o.jsx)(i.pre,{children:(0,o.jsx)(i.code,{className:"language-xml",children:'<?xml version="1.0"?>\r\n<robot name="humanoid_robot" xmlns:xacro="http://www.ros.org/wiki/xacro">\r\n\r\n  \x3c!-- Base link definition --\x3e\r\n  <link name="base_link">\r\n    <inertial>\r\n      <mass value="10.0"/>\r\n      <origin xyz="0 0 0.1" rpy="0 0 0"/>\r\n      <inertia ixx="0.1" ixy="0.0" ixz="0.0"\r\n               iyy="0.1" iyz="0.0" izz="0.1"/>\r\n    </inertial>\r\n\r\n    <visual>\r\n      <origin xyz="0 0 0.1" rpy="0 0 0"/>\r\n      <geometry>\r\n        <box size="0.3 0.2 0.2"/>\r\n      </geometry>\r\n      <material name="gray">\r\n        <color rgba="0.5 0.5 0.5 1.0"/>\r\n      </material>\r\n    </visual>\r\n\r\n    <collision>\r\n      <origin xyz="0 0 0.1" rpy="0 0 0"/>\r\n      <geometry>\r\n        <box size="0.3 0.2 0.2"/>\r\n      </geometry>\r\n    </collision>\r\n  </link>\r\n\r\n  \x3c!-- Torso link --\x3e\r\n  <link name="torso">\r\n    <inertial>\r\n      <mass value="8.0"/>\r\n      <origin xyz="0 0 0.2" rpy="0 0 0"/>\r\n      <inertia ixx="0.08" ixy="0.0" ixz="0.0"\r\n               iyy="0.08" iyz="0.0" izz="0.08"/>\r\n    </inertial>\r\n\r\n    <visual>\r\n      <origin xyz="0 0 0.2" rpy="0 0 0"/>\r\n      <geometry>\r\n        <box size="0.2 0.15 0.4"/>\r\n      </geometry>\r\n      <material name="blue">\r\n        <color rgba="0.2 0.2 0.8 1.0"/>\r\n      </material>\r\n    </visual>\r\n\r\n    <collision>\r\n      <origin xyz="0 0 0.2" rpy="0 0 0"/>\r\n      <geometry>\r\n        <box size="0.2 0.15 0.4"/>\r\n      </geometry>\r\n    </collision>\r\n  </link>\r\n\r\n  \x3c!-- Joint connecting base to torso --\x3e\r\n  <joint name="base_torso_joint" type="fixed">\r\n    <parent link="base_link"/>\r\n    <child link="torso"/>\r\n    <origin xyz="0 0 0.2" rpy="0 0 0"/>\r\n  </joint>\r\n\r\n  \x3c!-- Hip joint and leg links --\x3e\r\n  <joint name="left_hip_joint" type="revolute">\r\n    <parent link="torso"/>\r\n    <child link="left_thigh"/>\r\n    <origin xyz="-0.05 -0.1 0.2" rpy="0 0 0"/>\r\n    <axis xyz="1 0 0"/>\r\n    <limit lower="-1.57" upper="1.57" effort="100" velocity="2"/>\r\n    <dynamics damping="0.1" friction="0.0"/>\r\n  </joint>\r\n\r\n  <link name="left_thigh">\r\n    <inertial>\r\n      <mass value="3.0"/>\r\n      <origin xyz="0 0 -0.15" rpy="0 0 0"/>\r\n      <inertia ixx="0.02" ixy="0.0" ixz="0.0"\r\n               iyy="0.02" iyz="0.0" izz="0.02"/>\r\n    </inertial>\r\n\r\n    <visual>\r\n      <origin xyz="0 0 -0.15" rpy="0 0 0"/>\r\n      <geometry>\r\n        <cylinder length="0.3" radius="0.05"/>\r\n      </geometry>\r\n      <material name="red">\r\n        <color rgba="0.8 0.2 0.2 1.0"/>\r\n      </material>\r\n    </visual>\r\n\r\n    <collision>\r\n      <origin xyz="0 0 -0.15" rpy="0 0 0"/>\r\n      <geometry>\r\n        <cylinder length="0.3" radius="0.05"/>\r\n      </geometry>\r\n    </collision>\r\n  </link>\r\n\r\n  \x3c!-- Additional joints and links for complete humanoid model --\x3e\r\n  <joint name="left_knee_joint" type="revolute">\r\n    <parent link="left_thigh"/>\r\n    <child link="left_shin"/>\r\n    <origin xyz="0 0 -0.3" rpy="0 0 0"/>\r\n    <axis xyz="1 0 0"/>\r\n    <limit lower="-2.0" upper="0.5" effort="100" velocity="2"/>\r\n    <dynamics damping="0.1" friction="0.0"/>\r\n  </joint>\r\n\r\n  <link name="left_shin">\r\n    <inertial>\r\n      <mass value="2.0"/>\r\n      <origin xyz="0 0 -0.15" rpy="0 0 0"/>\r\n      <inertia ixx="0.01" ixy="0.0" ixz="0.0"\r\n               iyy="0.01" iyz="0.0" izz="0.01"/>\r\n    </inertial>\r\n\r\n    <visual>\r\n      <origin xyz="0 0 -0.15" rpy="0 0 0"/>\r\n      <geometry>\r\n        <cylinder length="0.3" radius="0.04"/>\r\n      </geometry>\r\n      <material name="green">\r\n        <color rgba="0.2 0.8 0.2 1.0"/>\r\n      </material>\r\n    </visual>\r\n\r\n    <collision>\r\n      <origin xyz="0 0 -0.15" rpy="0 0 0"/>\r\n      <geometry>\r\n        <cylinder length="0.3" radius="0.04"/>\r\n      </geometry>\r\n    </collision>\r\n  </link>\r\n\r\n  \x3c!-- Foot joint and link --\x3e\r\n  <joint name="left_ankle_joint" type="revolute">\r\n    <parent link="left_shin"/>\r\n    <child link="left_foot"/>\r\n    <origin xyz="0 0 -0.3" rpy="0 0 0"/>\r\n    <axis xyz="0 1 0"/>\r\n    <limit lower="-0.5" upper="0.5" effort="50" velocity="1"/>\r\n    <dynamics damping="0.05" friction="0.0"/>\r\n  </joint>\r\n\r\n  <link name="left_foot">\r\n    <inertial>\r\n      <mass value="1.0"/>\r\n      <origin xyz="0.05 0 -0.05" rpy="0 0 0"/>\r\n      <inertia ixx="0.005" ixy="0.0" ixz="0.0"\r\n               iyy="0.005" iyz="0.0" izz="0.005"/>\r\n    </inertial>\r\n\r\n    <visual>\r\n      <origin xyz="0.05 0 -0.05" rpy="0 0 0"/>\r\n      <geometry>\r\n        <box size="0.15 0.1 0.05"/>\r\n      </geometry>\r\n      <material name="yellow">\r\n        <color rgba="0.8 0.8 0.2 1.0"/>\r\n      </material>\r\n    </visual>\r\n\r\n    <collision>\r\n      <origin xyz="0.05 0 -0.05" rpy="0 0 0"/>\r\n      <geometry>\r\n        <box size="0.15 0.1 0.05"/>\r\n      </geometry>\r\n    </collision>\r\n  </link>\r\n\r\n  \x3c!-- Gazebo-specific configurations --\x3e\r\n  <gazebo reference="base_link">\r\n    <material>Gazebo/Grey</material>\r\n  </gazebo>\r\n\r\n  <gazebo reference="torso">\r\n    <material>Gazebo/Blue</material>\r\n  </gazebo>\r\n\r\n  <gazebo reference="left_thigh">\r\n    <material>Gazebo/Red</material>\r\n  </gazebo>\r\n\r\n  <gazebo reference="left_shin">\r\n    <material>Gazebo/Green</material>\r\n  </gazebo>\r\n\r\n  <gazebo reference="left_foot">\r\n    <material>Gazebo/Yellow</material>\r\n  </gazebo>\r\n\r\n  \x3c!-- Gazebo plugins for control --\x3e\r\n  <gazebo>\r\n    <plugin name="gazebo_ros_control" filename="libgazebo_ros_control.so">\r\n      <robotNamespace>/humanoid_robot</robotNamespace>\r\n    </plugin>\r\n  </gazebo>\r\n\r\n</robot>\n'})}),"\n",(0,o.jsx)(i.h3,{id:"link-and-joint-definitions",children:"Link and Joint Definitions"}),"\n",(0,o.jsx)(i.p,{children:"In the URDF format:"}),"\n",(0,o.jsxs)(i.ul,{children:["\n",(0,o.jsxs)(i.li,{children:[(0,o.jsx)(i.strong,{children:"Links"})," represent rigid bodies with mass, inertia, and geometry"]}),"\n",(0,o.jsxs)(i.li,{children:[(0,o.jsx)(i.strong,{children:"Joints"})," define the connection between links with specific degrees of freedom"]}),"\n",(0,o.jsxs)(i.li,{children:[(0,o.jsx)(i.strong,{children:"Visual"})," elements define how the robot appears in simulation"]}),"\n",(0,o.jsxs)(i.li,{children:[(0,o.jsx)(i.strong,{children:"Collision"})," elements define physical interaction boundaries"]}),"\n"]}),"\n",(0,o.jsx)(i.h3,{id:"collision-and-visual-geometries",children:"Collision and Visual Geometries"}),"\n",(0,o.jsx)(i.p,{children:"Proper configuration of collision and visual geometries is crucial for realistic simulation:"}),"\n",(0,o.jsxs)(i.ul,{children:["\n",(0,o.jsxs)(i.li,{children:[(0,o.jsx)(i.strong,{children:"Visual geometries"})," determine how the robot appears (for rendering)"]}),"\n",(0,o.jsxs)(i.li,{children:[(0,o.jsx)(i.strong,{children:"Collision geometries"})," determine physical interactions (for physics simulation)"]}),"\n",(0,o.jsx)(i.li,{children:"Collision geometries should be simplified compared to visual geometries for performance"}),"\n"]}),"\n",(0,o.jsx)(i.h2,{id:"robot-modeling-in-unity",children:"Robot Modeling in Unity"}),"\n",(0,o.jsx)(i.p,{children:"Unity provides different approaches for robot modeling, including direct import of URDF files and manual creation of robot components."}),"\n",(0,o.jsx)(i.h3,{id:"importing-urdf-models-to-unity",children:"Importing URDF Models to Unity"}),"\n",(0,o.jsx)(i.p,{children:"The Unity URDF Importer package enables direct import of ROS robot models:"}),"\n",(0,o.jsx)(i.pre,{children:(0,o.jsx)(i.code,{className:"language-csharp",children:'using UnityEngine;\r\nusing Unity.Robotics.URDFImporter;\r\n\r\npublic class RobotModelLoader : MonoBehaviour\r\n{\r\n    [Header("URDF Configuration")]\r\n    public string urdfPath;\r\n    public string robotName;\r\n\r\n    [Header("Import Settings")]\r\n    public bool createArticulations = true;\r\n    public bool useCollision = true;\r\n    public bool useInertia = true;\r\n\r\n    void Start()\r\n    {\r\n        LoadRobotModel();\r\n    }\r\n\r\n    public void LoadRobotModel()\r\n    {\r\n        if (!string.IsNullOrEmpty(urdfPath))\r\n        {\r\n            // Load URDF file and create robot model\r\n            var robot = URDFRobotExtensions.CreateRobot(urdfPath);\r\n\r\n            if (robot != null)\r\n            {\r\n                robot.transform.SetParent(transform);\r\n                ConfigureRobotPhysics(robot);\r\n            }\r\n        }\r\n    }\r\n\r\n    void ConfigureRobotPhysics(GameObject robot)\r\n    {\r\n        // Configure rigidbodies for each link\r\n        var links = robot.GetComponentsInChildren<LinkComponent>();\r\n        foreach (var link in links)\r\n        {\r\n            ConfigureLinkPhysics(link);\r\n        }\r\n\r\n        // Configure joints between links\r\n        var joints = robot.GetComponentsInChildren<JointComponent>();\r\n        foreach (var joint in joints)\r\n        {\r\n            ConfigureJointConstraints(joint);\r\n        }\r\n    }\r\n\r\n    void ConfigureLinkPhysics(LinkComponent link)\r\n    {\r\n        var rb = link.GetComponent<Rigidbody>();\r\n        if (rb == null)\r\n        {\r\n            rb = link.gameObject.AddComponent<Rigidbody>();\r\n        }\r\n\r\n        // Set physical properties from URDF\r\n        rb.mass = link.urdfMass;\r\n        rb.centerOfMass = link.urdfCenterOfMass;\r\n        rb.inertiaTensor = link.urdfInertiaTensor;\r\n    }\r\n\r\n    void ConfigureJointConstraints(JointComponent joint)\r\n    {\r\n        var jointComponent = joint.GetComponent<UnityEngine.Joint>();\r\n        if (jointComponent != null)\r\n        {\r\n            // Configure joint based on URDF joint type\r\n            switch (joint.urdfJointType)\r\n            {\r\n                case JointType.Revolute:\r\n                case JointType.Continuous:\r\n                    var hingeJoint = jointComponent as HingeJoint;\r\n                    if (hingeJoint != null)\r\n                    {\r\n                        hingeJoint.limits = new JointLimits\r\n                        {\r\n                            min = joint.urdfLowerLimit,\r\n                            max = joint.urdfUpperLimit,\r\n                            bounciness = 0.1f\r\n                        };\r\n                        hingeJoint.useLimits = true;\r\n                        hingeJoint.useSpring = true;\r\n                        hingeJoint.spring = new JointSpring\r\n                        {\r\n                            spring = joint.urdfEffortLimit * 0.1f,\r\n                            damper = joint.urdfVelocityLimit * 0.1f,\r\n                            targetPosition = 0\r\n                        };\r\n                    }\r\n                    break;\r\n\r\n                case JointType.Prismatic:\r\n                    var configurableJoint = jointComponent as ConfigurableJoint;\r\n                    if (configurableJoint != null)\r\n                    {\r\n                        configurableJoint.linearLimit = new SoftJointLimit\r\n                        {\r\n                            limit = joint.urdfUpperLimit\r\n                        };\r\n                    }\r\n                    break;\r\n            }\r\n        }\r\n    }\r\n}\n'})}),"\n",(0,o.jsx)(i.h3,{id:"manual-robot-creation-in-unity",children:"Manual Robot Creation in Unity"}),"\n",(0,o.jsx)(i.p,{children:"For custom robot models or when not using URDF:"}),"\n",(0,o.jsx)(i.pre,{children:(0,o.jsx)(i.code,{className:"language-csharp",children:'using UnityEngine;\r\n\r\n[RequireComponent(typeof(Rigidbody))]\r\npublic class HumanoidLink : MonoBehaviour\r\n{\r\n    [Header("Physical Properties")]\r\n    public float mass = 1.0f;\r\n    public Vector3 centerOfMass = Vector3.zero;\r\n    public Vector3 inertiaTensor = Vector3.one;\r\n\r\n    [Header("Joint Configuration")]\r\n    public JointType jointType = JointType.Revolute;\r\n    public Vector3 jointAxis = Vector3.right;\r\n\r\n    [Header("Joint Limits")]\r\n    [Range(-180f, 180f)] public float lowerLimit = -90f;\r\n    [Range(-180f, 180f)] public float upperLimit = 90f;\r\n\r\n    [Header("Actuation")]\r\n    public float maxEffort = 100f;\r\n    public float maxVelocity = 2f;\r\n\r\n    private Rigidbody rb;\r\n    private Joint joint;\r\n\r\n    void Start()\r\n    {\r\n        InitializePhysics();\r\n        ConfigureJoint();\r\n    }\r\n\r\n    void InitializePhysics()\r\n    {\r\n        rb = GetComponent<Rigidbody>();\r\n        rb.mass = mass;\r\n        rb.centerOfMass = centerOfMass;\r\n        rb.inertiaTensor = inertiaTensor;\r\n\r\n        // Add collision if needed\r\n        if (GetComponent<Collider>() == null)\r\n        {\r\n            // Add appropriate collider based on link shape\r\n            var meshFilter = GetComponent<MeshFilter>();\r\n            if (meshFilter != null && meshFilter.sharedMesh != null)\r\n            {\r\n                gameObject.AddComponent<MeshCollider>();\r\n            }\r\n            else\r\n            {\r\n                // Default to box collider\r\n                var boxCollider = gameObject.AddComponent<BoxCollider>();\r\n                boxCollider.center = centerOfMass;\r\n            }\r\n        }\r\n    }\r\n\r\n    void ConfigureJoint()\r\n    {\r\n        // Configure joint based on type\r\n        switch (jointType)\r\n        {\r\n            case JointType.Revolute:\r\n                ConfigureHingeJoint();\r\n                break;\r\n            case JointType.Prismatic:\r\n                ConfigurePrismaticJoint();\r\n                break;\r\n            case JointType.Fixed:\r\n                ConfigureFixedJoint();\r\n                break;\r\n        }\r\n    }\r\n\r\n    void ConfigureHingeJoint()\r\n    {\r\n        var hingeJoint = gameObject.AddComponent<HingeJoint>();\r\n        hingeJoint.axis = jointAxis;\r\n        hingeJoint.limits = new JointLimits\r\n        {\r\n            min = lowerLimit,\r\n            max = upperLimit,\r\n            bounciness = 0.1f\r\n        };\r\n        hingeJoint.useLimits = true;\r\n        hingeJoint.motor = new JointMotor\r\n        {\r\n            targetVelocity = 0,\r\n            force = maxEffort,\r\n            freeSpin = false\r\n        };\r\n        hingeJoint.useMotor = true;\r\n\r\n        joint = hingeJoint;\r\n    }\r\n\r\n    void ConfigurePrismaticJoint()\r\n    {\r\n        var configurableJoint = gameObject.AddComponent<ConfigurableJoint>();\r\n        configurableJoint.axis = jointAxis;\r\n        configurableJoint.secondaryAxis = Vector3.Cross(jointAxis, Vector3.up);\r\n\r\n        configurableJoint.linearLimit = new SoftJointLimit\r\n        {\r\n            limit = Mathf.Max(Mathf.Abs(lowerLimit), Mathf.Abs(upperLimit))\r\n        };\r\n\r\n        joint = configurableJoint;\r\n    }\r\n\r\n    void ConfigureFixedJoint()\r\n    {\r\n        var fixedJoint = gameObject.AddComponent<FixedJoint>();\r\n        joint = fixedJoint;\r\n    }\r\n\r\n    public void ApplyJointTorque(float torque)\r\n    {\r\n        if (joint is HingeJoint hingeJoint)\r\n        {\r\n            var motor = hingeJoint.motor;\r\n            motor.targetVelocity = Mathf.Clamp(torque / maxEffort * maxVelocity, -maxVelocity, maxVelocity);\r\n            motor.force = Mathf.Abs(torque);\r\n            hingeJoint.motor = motor;\r\n            hingeJoint.useMotor = true;\r\n        }\r\n    }\r\n}\r\n\r\npublic enum JointType\r\n{\r\n    Revolute,\r\n    Prismatic,\r\n    Fixed,\r\n    Continuous\r\n}\n'})}),"\n",(0,o.jsx)(i.h2,{id:"physics-configuration-and-tuning",children:"Physics Configuration and Tuning"}),"\n",(0,o.jsx)(i.p,{children:"Proper physics configuration is essential for realistic simulation behavior that matches physical robot characteristics."}),"\n",(0,o.jsx)(i.h3,{id:"physics-parameters-for-realistic-simulation",children:"Physics Parameters for Realistic Simulation"}),"\n",(0,o.jsx)(i.p,{children:"The physics parameters should match the physical robot's characteristics:"}),"\n",(0,o.jsxs)(i.ul,{children:["\n",(0,o.jsxs)(i.li,{children:[(0,o.jsx)(i.strong,{children:"Mass"}),": Accurate mass values for each link"]}),"\n",(0,o.jsxs)(i.li,{children:[(0,o.jsx)(i.strong,{children:"Inertia"}),": Proper moment of inertia tensors"]}),"\n",(0,o.jsxs)(i.li,{children:[(0,o.jsx)(i.strong,{children:"Damping"}),": Appropriate damping coefficients for joints"]}),"\n",(0,o.jsxs)(i.li,{children:[(0,o.jsx)(i.strong,{children:"Friction"}),": Realistic friction values for contact surfaces"]}),"\n"]}),"\n",(0,o.jsx)(i.h3,{id:"damping-and-friction-configuration",children:"Damping and Friction Configuration"}),"\n",(0,o.jsx)(i.p,{children:"Damping and friction parameters affect robot behavior significantly:"}),"\n",(0,o.jsx)(i.pre,{children:(0,o.jsx)(i.code,{className:"language-csharp",children:'using UnityEngine;\r\n\r\npublic class PhysicsTuner : MonoBehaviour\r\n{\r\n    [Header("Joint Damping Configuration")]\r\n    public float globalDamping = 0.1f;\r\n    public float globalFriction = 0.0f;\r\n\r\n    [Header("Contact Properties")]\r\n    public float contactStiffness = 100000f;\r\n    public float contactDamping = 1000f;\r\n\r\n    public void ConfigurePhysicsParameters()\r\n    {\r\n        // Configure global physics settings\r\n        Physics.defaultSolverIterations = 10;\r\n        Physics.defaultSolverVelocityIterations = 20;\r\n        Physics.sleepThreshold = 0.005f;\r\n        Physics.defaultContactOffset = 0.01f;\r\n\r\n        // Apply to all rigidbodies in robot\r\n        var rigidbodies = GetComponentsInChildren<Rigidbody>();\r\n        foreach (var rb in rigidbodies)\r\n        {\r\n            ConfigureRigidbody(rb);\r\n        }\r\n\r\n        // Configure all joints in robot\r\n        var joints = GetComponentsInChildren<Joint>();\r\n        foreach (var joint in joints)\r\n        {\r\n            ConfigureJoint(joint);\r\n        }\r\n    }\r\n\r\n    void ConfigureRigidbody(Rigidbody rb)\r\n    {\r\n        // Set damping properties\r\n        rb.drag = globalDamping;\r\n        rb.angularDrag = globalDamping * 0.5f;\r\n    }\r\n\r\n    void ConfigureJoint(Joint joint)\r\n    {\r\n        // Configure joint-specific damping\r\n        if (joint is HingeJoint hinge)\r\n        {\r\n            var spring = hinge.spring;\r\n            spring.spring = globalDamping * 100f;\r\n            spring.damper = globalDamping * 10f;\r\n            hinge.spring = spring;\r\n        }\r\n        else if (joint is ConfigurableJoint configurable)\r\n        {\r\n            configurable.angularXMotion = ConfigurableJointMotion.Limited;\r\n            configurable.angularYMotion = ConfigurableJointMotion.Limited;\r\n            configurable.angularZMotion = ConfigurableJointMotion.Limited;\r\n\r\n            // Set angular limits with damping\r\n            var angularLimit = configurable.angularXLimit;\r\n            angularLimit.limit = 45f; // degrees\r\n            configurable.angularXLimit = angularLimit;\r\n        }\r\n    }\r\n\r\n    public void MatchPhysicalRobot(HumanoidRobotSpec physicalSpec)\r\n    {\r\n        // Apply physical robot specifications to simulation\r\n        var links = GetComponentsInChildren<HumanoidLink>();\r\n\r\n        foreach (var link in links)\r\n        {\r\n            var spec = physicalSpec.GetLinkSpec(link.name);\r\n            if (spec != null)\r\n            {\r\n                link.mass = spec.mass;\r\n                link.centerOfMass = spec.centerOfMass;\r\n                link.inertiaTensor = spec.inertiaTensor;\r\n\r\n                // Update rigidbody with new values\r\n                var rb = link.GetComponent<Rigidbody>();\r\n                if (rb != null)\r\n                {\r\n                    rb.mass = spec.mass;\r\n                    rb.centerOfMass = spec.centerOfMass;\r\n                    rb.inertiaTensor = spec.inertiaTensor;\r\n                }\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n[System.Serializable]\r\npublic class HumanoidRobotSpec\r\n{\r\n    public LinkSpecification[] links;\r\n    public JointSpecification[] joints;\r\n\r\n    public LinkSpecification GetLinkSpec(string linkName)\r\n    {\r\n        foreach (var link in links)\r\n        {\r\n            if (link.name == linkName)\r\n                return link;\r\n        }\r\n        return null;\r\n    }\r\n}\r\n\r\n[System.Serializable]\r\npublic class LinkSpecification\r\n{\r\n    public string name;\r\n    public float mass;\r\n    public Vector3 centerOfMass;\r\n    public Vector3 inertiaTensor;\r\n    public float friction;\r\n    public float bounciness;\r\n}\r\n\r\n[System.Serializable]\r\npublic class JointSpecification\r\n{\r\n    public string name;\r\n    public JointType jointType;\r\n    public float lowerLimit;\r\n    public float upperLimit;\r\n    public float effortLimit;\r\n    public float velocityLimit;\r\n    public float damping;\r\n    public float friction;\r\n}\n'})}),"\n",(0,o.jsx)(i.h2,{id:"collision-geometry-and-visual-meshes",children:"Collision Geometry and Visual Meshes"}),"\n",(0,o.jsx)(i.p,{children:"Separating collision geometry from visual meshes is important for performance and accuracy."}),"\n",(0,o.jsx)(i.h3,{id:"optimization-techniques",children:"Optimization Techniques"}),"\n",(0,o.jsx)(i.p,{children:"For collision detection optimization:"}),"\n",(0,o.jsxs)(i.ul,{children:["\n",(0,o.jsx)(i.li,{children:"Use simplified geometries (boxes, spheres, capsules) for collision"}),"\n",(0,o.jsx)(i.li,{children:"Use detailed meshes only for visualization"}),"\n",(0,o.jsx)(i.li,{children:"Implement level-of-detail (LOD) systems for complex models"}),"\n",(0,o.jsx)(i.li,{children:"Use compound colliders for complex shapes"}),"\n"]}),"\n",(0,o.jsx)(i.h3,{id:"performance-considerations",children:"Performance Considerations"}),"\n",(0,o.jsx)(i.pre,{children:(0,o.jsx)(i.code,{className:"language-csharp",children:'using UnityEngine;\r\n\r\npublic class CollisionOptimizer : MonoBehaviour\r\n{\r\n    [Header("Optimization Settings")]\r\n    public bool optimizeColliders = true;\r\n    public bool useCompoundColliders = true;\r\n    public float simplificationFactor = 0.1f;\r\n\r\n    void Start()\r\n    {\r\n        if (optimizeColliders)\r\n        {\r\n            OptimizeRobotColliders();\r\n        }\r\n    }\r\n\r\n    void OptimizeRobotColliders()\r\n    {\r\n        var links = GetComponentsInChildren<HumanoidLink>();\r\n\r\n        foreach (var link in links)\r\n        {\r\n            OptimizeLinkCollider(link);\r\n        }\r\n    }\r\n\r\n    void OptimizeLinkCollider(HumanoidLink link)\r\n    {\r\n        var originalCollider = link.GetComponent<Collider>();\r\n        if (originalCollider == null) return;\r\n\r\n        // For complex meshes, replace with simpler collision shapes\r\n        var meshCollider = originalCollider as MeshCollider;\r\n        if (meshCollider != null && meshCollider.sharedMesh != null)\r\n        {\r\n            // Try to replace with primitive colliders if possible\r\n            var bounds = meshCollider.sharedMesh.bounds;\r\n            var size = bounds.size;\r\n\r\n            // Determine best primitive based on shape\r\n            if (IsApproximatelyCylindrical(size))\r\n            {\r\n                ReplaceWithCapsuleCollider(link.gameObject, bounds);\r\n            }\r\n            else if (IsApproximatelyBoxShaped(size))\r\n            {\r\n                ReplaceWithBoxCollider(link.gameObject, bounds);\r\n            }\r\n            else\r\n            {\r\n                // Keep mesh collider but simplify if possible\r\n                SimplifyMeshCollider(meshCollider);\r\n            }\r\n        }\r\n    }\r\n\r\n    bool IsApproximatelyCylindrical(Vector3 size)\r\n    {\r\n        // Check if two dimensions are similar and one is larger\r\n        var dimensions = new float[] { size.x, size.y, size.z };\r\n        System.Array.Sort(dimensions);\r\n        return (dimensions[1] / dimensions[0]) < 1.5f && (dimensions[2] / dimensions[1]) > 2f;\r\n    }\r\n\r\n    bool IsApproximatelyBoxShaped(Vector3 size)\r\n    {\r\n        // Check if all dimensions are within reasonable bounds\r\n        var ratioXY = size.x / size.y;\r\n        var ratioXZ = size.x / size.z;\r\n        var ratioYZ = size.y / size.z;\r\n\r\n        return Mathf.Abs(ratioXY - 1f) < 0.5f &&\r\n               Mathf.Abs(ratioXZ - 1f) < 0.5f &&\r\n               Mathf.Abs(ratioYZ - 1f) < 0.5f;\r\n    }\r\n\r\n    void ReplaceWithCapsuleCollider(GameObject link, Bounds bounds)\r\n    {\r\n        var capsuleCollider = link.AddComponent<CapsuleCollider>();\r\n\r\n        // Calculate capsule dimensions\r\n        var maxSize = Mathf.Max(bounds.size.x, bounds.size.z);\r\n        var height = bounds.size.y;\r\n\r\n        capsuleCollider.radius = maxSize / 2f;\r\n        capsuleCollider.height = height;\r\n        capsuleCollider.direction = 1; // Y-axis\r\n        capsuleCollider.center = bounds.center - (Vector3)link.transform.position;\r\n\r\n        // Remove original collider\r\n        var oldCollider = link.GetComponent<Collider>();\r\n        if (oldCollider != null)\r\n            DestroyImmediate(oldCollider);\r\n    }\r\n\r\n    void ReplaceWithBoxCollider(GameObject link, Bounds bounds)\r\n    {\r\n        var boxCollider = link.AddComponent<BoxCollider>();\r\n        boxCollider.size = bounds.size;\r\n        boxCollider.center = bounds.center - (Vector3)link.transform.position;\r\n\r\n        // Remove original collider\r\n        var oldCollider = link.GetComponent<Collider>();\r\n        if (oldCollider != null)\r\n            DestroyImmediate(oldCollider);\r\n    }\r\n\r\n    void SimplifyMeshCollider(MeshCollider meshCollider)\r\n    {\r\n        // In a real implementation, this would simplify the mesh\r\n        // For now, we\'ll just keep the original but mark it as optimized\r\n        meshCollider.convex = true; // Use convex hull for better performance\r\n    }\r\n}\n'})}),"\n",(0,o.jsx)(i.h2,{id:"conclusion",children:"Conclusion"}),"\n",(0,o.jsx)(i.p,{children:"Proper robot modeling and physics configuration are fundamental to creating accurate digital twins for humanoid robots. Whether using Gazebo with URDF or Unity with custom components, the key is to ensure that the virtual model accurately reflects the physical robot's characteristics, including mass distribution, joint constraints, and physical interactions. This accuracy is essential for the digital twin to provide meaningful insights and enable effective testing and validation of robot behaviors before deployment on the physical system."})]})}function m(n={}){const{wrapper:i}={...(0,t.R)(),...n.components};return i?(0,o.jsx)(i,{...n,children:(0,o.jsx)(d,{...n})}):d(n)}},8453(n,i,r){r.d(i,{R:()=>l,x:()=>s});var e=r(6540);const o={},t=e.createContext(o);function l(n){const i=e.useContext(t);return e.useMemo(function(){return"function"==typeof n?n(i):{...i,...n}},[i,n])}function s(n){let i;return i=n.disableParentContext?"function"==typeof n.components?n.components(o):n.components||o:l(n.components),e.createElement(t.Provider,{value:i},n.children)}}}]);